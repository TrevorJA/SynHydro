{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SynHydro","text":"<p>Synthetic Generation Library \u2014 stochastic streamflow generation for hydrologic analysis.</p> <p> </p> <p>SynHydro provides parametric, nonparametric, and machine-learning stochastic generation methods under a unified API. All generators share the same <code>preprocessing() \u2192 fit() \u2192 generate()</code> workflow.</p>"},{"location":"#generators","title":"Generators","text":"Class Type Frequency Sites Reference <code>KirschGenerator</code> Nonparametric Monthly Multi Kirsch et al. (2013) <code>PhaseRandomizationGenerator</code> Nonparametric Daily Single Brunner et al. (2019) <code>ThomasFieringGenerator</code> Parametric AR(1) Monthly Single Thomas &amp; Fiering (1962) <code>MATALASGenerator</code> Parametric MAR(1) Monthly Multi Matalas (1967) <code>MultiSiteHMMGenerator</code> Hidden Markov Model Annual Multi Gold et al. (2025) <code>WARMGenerator</code> Wavelet AR Annual Single Nowak et al. (2011)"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import synhydro\n\nQ_obs = synhydro.load_example_data()                       # daily DataFrame\nQ_monthly = Q_obs.resample(\"MS\").mean()                 # resample to monthly\n\ngen = synhydro.KirschGenerator(Q_monthly)\ngen.preprocessing()\ngen.fit()\nensemble = gen.generate(n_realizations=50, n_years=30, seed=42)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/TrevorJA/SynHydro.git\n</code></pre> <p>See Getting Started for full setup and data format details.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>SynHydro is not yet published on PyPI. Install directly from GitHub:</p> <pre><code>pip install git+https://github.com/TrevorJA/SynHydro.git\n</code></pre> <p>For development (editable install with dev extras):</p> <pre><code>git clone https://github.com/TrevorJA/SynHydro.git\ncd SynHydro\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#data-format","title":"Data Format","text":"<p>All generators expect a <code>pd.DataFrame</code> with a <code>DatetimeIndex</code>:</p> Property Requirement Index <code>DatetimeIndex</code> Monthly data <code>freq='MS'</code> (month-start) Daily data <code>freq='D'</code> Columns Site names (one column per gauge) Units cfs, MGD, or cms (consistent) <pre><code>import pandas as pd\n\n# Minimal example: single site, monthly\ndates = pd.date_range(\"1980-01\", periods=480, freq=\"MS\")\nQ_obs = pd.DataFrame({\"site_A\": [...]}, index=dates)\n</code></pre> <p>Use <code>synhydro.load_example_data()</code> to get a ready-to-use daily dataset:</p> <pre><code>import synhydro\n\nQ_daily = synhydro.load_example_data()                 # USGS daily streamflow (cms)\nQ_monthly = Q_daily.resample(\"MS\").mean()           # aggregate to monthly\n</code></pre>"},{"location":"getting-started/#choosing-a-generator","title":"Choosing a Generator","text":"Need Generator Monthly, single-site, parametric <code>ThomasFieringGenerator</code> Monthly, multi-site, parametric <code>MATALASGenerator</code> Monthly, multi-site, nonparametric <code>KirschGenerator</code> Daily, single-site <code>PhaseRandomizationGenerator</code> Annual, single-site <code>WARMGenerator</code> Annual, multi-site, drought-aware <code>MultiSiteHMMGenerator</code> Monthly\u2192Daily disaggregation <code>NowakDisaggregator</code> (or use a Pipeline)"},{"location":"getting-started/#basic-workflow","title":"Basic Workflow","text":"<p>Every generator follows the same three-step pattern:</p> <pre><code>gen = synhydro.ThomasFieringGenerator(Q_obs)\ngen.preprocessing()                                 # validate and prepare data\ngen.fit()                                           # estimate parameters\nensemble = gen.generate(n_realizations=10,          # synthetic flows\n                        n_years=30,\n                        seed=42)\n</code></pre> <p>See the Tutorials for worked examples.</p>"},{"location":"algorithms/","title":"Algorithms","text":"<p>SynHydro implements the following stochastic generation and disaggregation methods.</p>"},{"location":"algorithms/#generation-methods","title":"Generation Methods","text":"Algorithm Class Type Frequency Sites Thomas-Fiering AR(1) <code>ThomasFieringGenerator</code> Parametric Monthly Single Kirsch Bootstrap <code>KirschGenerator</code> Nonparametric Monthly Multi Matalas MAR(1) <code>MATALASGenerator</code> Parametric Monthly Multi Phase Randomization <code>PhaseRandomizationGenerator</code> Nonparametric Daily Single WARM <code>WARMGenerator</code> Parametric Annual Single Multi-Site HMM <code>MultiSiteHMMGenerator</code> Parametric Annual Multi"},{"location":"algorithms/#disaggregation-methods","title":"Disaggregation Methods","text":"Algorithm Class Type Frequency Nowak KNN <code>NowakDisaggregator</code> Nonparametric Monthly\u2192Daily"},{"location":"algorithms/#key-properties-preserved","title":"Key Properties Preserved","text":"Property Thomas-Fiering Kirsch Matalas Phase Random WARM HMM Monthly means/stds \u2713 \u2713 \u2713 \u2014 \u2014 \u2014 Temporal correlation \u2713 \u2713 \u2713 \u2713 \u2713 \u2713 Spatial correlation \u2014 \u2713 \u2713 \u2014 \u2014 \u2713 Non-stationarity \u2014 \u2014 \u2014 \u2014 \u2713 \u2014 Drought states \u2014 \u2014 \u2014 \u2014 \u2014 \u2713 Power spectrum \u2014 \u2014 \u2014 \u2713 \u2713 \u2014"},{"location":"algorithms/ALGO_TEMPLATE/","title":"[Method Name] ([Author et al. Year])","text":"Type [Parametric / Nonparametric / ML] Resolution [Monthly / Daily / Annual] Sites [Univariate / Multisite] Class <code>[ClassName]</code>"},{"location":"algorithms/ALGO_TEMPLATE/#overview","title":"Overview","text":"<p>[2-4 sentence description: what the method does, its core mechanism, and what it's best suited for.]</p>"},{"location":"algorithms/ALGO_TEMPLATE/#algorithm","title":"Algorithm","text":""},{"location":"algorithms/ALGO_TEMPLATE/#preprocessing","title":"Preprocessing","text":"<ol> <li>[Step]</li> <li>[Step]</li> </ol>"},{"location":"algorithms/ALGO_TEMPLATE/#fitting","title":"Fitting","text":"<ol> <li>[Step with key equations in code blocks]</li> <li>[Step]</li> </ol>"},{"location":"algorithms/ALGO_TEMPLATE/#generation","title":"Generation","text":"<ol> <li>[Step with key equations in code blocks]</li> <li>[Step]</li> </ol>"},{"location":"algorithms/ALGO_TEMPLATE/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>param</code> type value What it controls"},{"location":"algorithms/ALGO_TEMPLATE/#properties-preserved","title":"Properties Preserved","text":"<ul> <li>[Property 1]</li> <li>[Property 2]</li> </ul> <p>Not preserved: - [Limitation as property]</p>"},{"location":"algorithms/ALGO_TEMPLATE/#limitations","title":"Limitations","text":"<ul> <li>[Key limitation 1]</li> <li>[Key limitation 2]</li> </ul>"},{"location":"algorithms/ALGO_TEMPLATE/#references","title":"References","text":"<p>Primary: [Full APA citation with DOI]</p> <p>See also: - [Supporting citation]</p> <p>Implementation: <code>src/synhydro/methods/generation/[category]/[file].py</code> Tests: <code>tests/test_[name].py</code></p>"},{"location":"algorithms/kirsch/","title":"Kirsch (2013) Monthly Bootstrap Generator","text":"Type Nonparametric Resolution Monthly Sites Multisite Class <code>KirschGenerator</code>"},{"location":"algorithms/kirsch/#overview","title":"Overview","text":"<p>The Kirsch method generates synthetic multi-site monthly streamflow by bootstrapping standardized residuals and imposing fitted correlation structure via Cholesky decomposition. A cross-year shifted matrix preserves December-to-January correlations. An optional normal score transform prevents bias when working in log-space.</p>"},{"location":"algorithms/kirsch/#algorithm","title":"Algorithm","text":""},{"location":"algorithms/kirsch/#preprocessing","title":"Preprocessing","text":"<ol> <li>Aggregate to monthly \u2014 group by (year, month) and sum.</li> <li>Optional log transform \u2014 if <code>generate_using_log_flow=True</code>, apply <code>log(Q)</code> (clipped at 1e-6).</li> </ol>"},{"location":"algorithms/kirsch/#fitting","title":"Fitting","text":"<ol> <li>Monthly statistics \u2014 for each month m and site s, compute mean and standard deviation.</li> <li>Standardized residuals:    <pre><code>Z_h[y, m, s] = (Q[y, m, s] - mean[m, s]) / std[m, s]\n</code></pre></li> <li>Normal score transform (if log-flow) \u2014 for each month-site pair:</li> <li>Rank residuals, map to normal quantiles via Hazen plotting positions</li> <li>Store mapping for inverse transform during generation</li> <li>Result: <code>Y</code> in standard normal space</li> <li>Cross-year shifted matrix <code>Y_prime</code> \u2014 preserves inter-year correlations:    <pre><code>Y_prime[:, 0:6, :]  = Y[:-1, 6:12, :]   # Jul-Dec of year i\nY_prime[:, 6:12, :] = Y[1:, 0:6, :]      # Jan-Jun of year i+1\n</code></pre></li> <li>Cholesky decomposition \u2014 for each site, compute 12x12 correlation matrix of Y (and Y_prime), repair if not PSD (spectral method), then Cholesky factor.</li> </ol>"},{"location":"algorithms/kirsch/#generation","title":"Generation","text":"<ol> <li>Bootstrap \u2014 sample random year indices for each (year, month) position.</li> <li>Cholesky mixing \u2014 multiply bootstrap samples by Cholesky factor to impose correlation:    <pre><code>Z[:, :, s] = X[:, :, s] @ U[s]\n</code></pre></li> <li>Combine Z and Z_prime to preserve intra-year correlations:    <pre><code>ZC[i, 0:6, :]  = Z_prime[i, 6:12, :]    # first half from shifted\nZC[i, 6:12, :] = Z[i+1, 6:12, :]         # second half from regular\n</code></pre></li> <li>Inverse normal score transform (if log-flow) \u2014 map back using stored mappings with linear tail extrapolation.</li> <li>Destandardize: <code>Q_syn = ZC * std[m] + mean[m]</code></li> <li>Back-transform from log space if applicable: <code>Q_syn = exp(Q_syn)</code></li> </ol>"},{"location":"algorithms/kirsch/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>generate_using_log_flow</code> <code>bool</code> <code>True</code> Log-transform before processing (recommended for skewed data) <code>matrix_repair_method</code> <code>str</code> <code>'spectral'</code> Method for repairing non-PSD correlation matrices"},{"location":"algorithms/kirsch/#properties-preserved","title":"Properties Preserved","text":"<ul> <li>Monthly means and standard deviations (per site)</li> <li>Spatial cross-site correlations (via Cholesky decomposition)</li> <li>Intra-annual temporal correlation (within and across year boundaries)</li> <li>Empirical marginal distributions (nonparametric)</li> </ul> <p>Not preserved: - Values outside observed range (bootstrap limitation, except via NST tail extrapolation)</p>"},{"location":"algorithms/kirsch/#limitations","title":"Limitations","text":"<ul> <li>Requires complete years (all 12 months present per year)</li> <li>Y_prime construction loses one year of data</li> <li>Sample correlation matrices may require PSD repair, which can inflate correlations</li> <li>Bootstrap resampling bounded by historical range</li> </ul>"},{"location":"algorithms/kirsch/#references","title":"References","text":"<p>Primary: Kirsch, B.R., Characklis, G.W., and Zeff, H.B. (2013). Evaluating the impact of alternative hydro-climate scenarios on transfer agreements: A practical improvement for generating synthetic streamflows. Journal of Water Resources Planning and Management, 139(4), 396-406. https://doi.org/10.1061/(ASCE)WR.1943-5452.0000287</p> <p>Implementation: <code>src/synhydro/methods/generation/nonparametric/kirsch.py</code> Tests: <code>tests/test_kirsch_generator.py</code></p>"},{"location":"algorithms/matalas/","title":"Matalas (1967) Multi-Site MAR(1)","text":"Type Parametric Resolution Monthly Sites Multisite Class <code>MATALASGenerator</code>"},{"location":"algorithms/matalas/#overview","title":"Overview","text":"<p>The Matalas MAR(1) model is the classical parametric baseline for multi-site stochastic streamflow generation. It extends the univariate Thomas-Fiering model to n sites by fitting a matrix autoregressive model to standardized monthly flows. A separate pair of coefficient matrices is estimated for each of the 12 calendar-month transitions.</p>"},{"location":"algorithms/matalas/#algorithm","title":"Algorithm","text":""},{"location":"algorithms/matalas/#preprocessing","title":"Preprocessing","text":"<ol> <li>Validate input; resample to monthly if daily data are provided.</li> <li>Clip values to 1e-6 to avoid log of zero.</li> <li>Optionally apply <code>log(Q + 1)</code> transformation to reduce skewness.</li> </ol>"},{"location":"algorithms/matalas/#fitting","title":"Fitting","text":"<ol> <li>Standardize observed flows by monthly means and standard deviations:    <pre><code>Z(t) = (Q(t) - mu_m) / sigma_m,    m = month(t)\n</code></pre></li> <li>Estimate cross-correlation matrices for each transition m to m+1:    <pre><code>S0(m) = (1/(n-1)) * Z(m)^T * Z(m)         # lag-0 covariance\nS1(m) = (1/(n-1)) * Z(m+1)^T * Z(m)        # lag-1 cross-covariance\n</code></pre></li> <li>Solve for coefficient matrices: <pre><code>A(m) = S1(m) * S0(m)^{-1}                   # AR coefficient matrix\nM(m) = S0(m+1) - A(m) * S0(m) * A(m)^T      # innovation covariance\nB(m) = cholesky(M(m))                         # lower Cholesky factor\n</code></pre>    If M(m) is not positive semi-definite, project to nearest PSD matrix via eigenvalue clipping before Cholesky decomposition.</li> </ol> <p>The December to January transition wraps across the year boundary.</p>"},{"location":"algorithms/matalas/#generation","title":"Generation","text":"<ol> <li>Initialize: <code>Z_0 ~ N(0, I)</code></li> <li>Recurse for each subsequent month:    <pre><code>Z(t+1) = A(m) * Z(t) + B(m) * epsilon(t+1),    epsilon ~ N(0, I)\n</code></pre></li> <li>Back-transform to flow space:    <pre><code>Q(t) = sigma_m * Z(t) + mu_m\n</code></pre></li> <li>If log transform was applied: <code>Q = exp(Q) - 1</code></li> </ol>"},{"location":"algorithms/matalas/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>log_transform</code> <code>bool</code> <code>True</code> Apply log(Q+1) before standardization"},{"location":"algorithms/matalas/#properties-preserved","title":"Properties Preserved","text":"<ul> <li>Monthly means and standard deviations at each site</li> <li>Lag-1 serial correlation at each site</li> <li>Contemporaneous cross-site correlations</li> </ul> <p>Not preserved: - Higher-order autocorrelation (lag &gt; 1) - Non-Gaussian marginal distributions</p>"},{"location":"algorithms/matalas/#limitations","title":"Limitations","text":"<ul> <li>First-order memory only (lag-1)</li> <li>Normality assumption after transformation</li> <li>Requires sufficient record length for stable covariance estimation</li> <li>Covariance matrices may require PSD repair with limited data</li> </ul>"},{"location":"algorithms/matalas/#references","title":"References","text":"<p>Primary: Matalas, N.C. (1967). Mathematical assessment of synthetic hydrology. Water Resources Research, 3(4), 937-945. https://doi.org/10.1029/WR003i004p00937</p> <p>See also: - Salas, J.D., Delleur, J.W., Yevjevich, V., and Lane, W.L. (1980). Applied Modeling of Hydrologic Time Series. Water Resources Publications.</p> <p>Implementation: <code>src/synhydro/methods/generation/parametric/matalas.py</code> Tests: <code>tests/test_matalas_generator.py</code></p>"},{"location":"algorithms/multisite_hmm/","title":"Multi-Site Hidden Markov Model (Gold et al. 2024)","text":"Type Parametric Resolution Annual Sites Multisite Class <code>MultiSiteHMMGenerator</code>"},{"location":"algorithms/multisite_hmm/#overview","title":"Overview","text":"<p>The Multi-Site HMM uses a Gaussian Mixture Model HMM to generate synthetic streamflow across multiple sites simultaneously. Hidden states represent hydrologic regimes (e.g., dry/wet), with state-specific multivariate Gaussian emissions capturing spatial correlations via full covariance matrices. Temporal dependence arises from the Markov state transition structure. This approach is particularly effective for modeling drought dynamics and spatially compounding water scarcity.</p>"},{"location":"algorithms/multisite_hmm/#algorithm","title":"Algorithm","text":""},{"location":"algorithms/multisite_hmm/#preprocessing","title":"Preprocessing","text":"<ol> <li>Validate input as multi-site DataFrame; optionally select site subset.</li> <li>Add offset to handle zeros: <code>Q_adj = Q + offset</code> (default: 1.0).</li> <li>Log-transform: <code>Q_log = log(Q_adj)</code>.</li> </ol>"},{"location":"algorithms/multisite_hmm/#fitting","title":"Fitting","text":"<ol> <li>Initialize GMMHMM via <code>hmmlearn.hmm.GMMHMM</code>:</li> <li><code>n_components = n_states</code> (default 2: dry/wet)</li> <li><code>covariance_type = 'full'</code> (preserves spatial correlations)</li> <li>Fit via Baum-Welch (EM) algorithm on log-transformed flows:</li> <li>E-step: compute state posteriors via forward-backward</li> <li>M-step: update state means, covariances, and transition probabilities</li> <li>Order states by mean of first site (ascending: driest \u2192 wettest).</li> <li>Compute stationary distribution \u2014 solve for left eigenvector of transition matrix with eigenvalue 1.</li> </ol>"},{"location":"algorithms/multisite_hmm/#generation","title":"Generation","text":"<ol> <li>State trajectory \u2014 sample initial state from stationary distribution, then at each timestep sample next state from transition matrix row.</li> <li>Emission sampling \u2014 for each timestep with state s:    <pre><code>Q_log[t, :] ~ MultivariateNormal(mu_s, Sigma_s)\n</code></pre></li> <li>Back-transform: <code>Q_syn = exp(Q_log) - offset</code>, then clip negatives to 0.</li> <li>Build output \u2014 create DataFrame with DatetimeIndex at inferred frequency.</li> </ol>"},{"location":"algorithms/multisite_hmm/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>n_states</code> <code>int</code> <code>2</code> Number of hidden states (2 = dry/wet) <code>offset</code> <code>float</code> <code>1.0</code> Additive offset before log transform <code>max_iterations</code> <code>int</code> <code>1000</code> Maximum EM iterations <code>covariance_type</code> <code>str</code> <code>'full'</code> Covariance structure: <code>'full'</code>, <code>'diag'</code>, or <code>'spherical'</code>"},{"location":"algorithms/multisite_hmm/#properties-preserved","title":"Properties Preserved","text":"<ul> <li>Spatial correlations (via full covariance matrices per state)</li> <li>Temporal persistence (via Markov state transitions)</li> <li>Regime-dependent distributions (distinct mean/covariance per state)</li> <li>Drought frequency and spatial extent (via dry-state persistence)</li> </ul> <p>Not preserved: - Autocorrelation at lags &gt; 1 (first-order Markov) - Non-Gaussian marginal distributions (log-normality imposed) - Trends or non-stationarity</p>"},{"location":"algorithms/multisite_hmm/#limitations","title":"Limitations","text":"<ul> <li>Requires 20+ years for 2 states; 50+ for more states</li> <li>First-order Markov \u2014 may miss multi-year drought persistence</li> <li>Full covariance becomes expensive for n_sites &gt; 20 (consider <code>'diag'</code>)</li> <li>EM may converge to local optima; multiple initializations recommended</li> <li>State label switching: ordering by mean ensures consistency but different seeds may find different optima</li> </ul>"},{"location":"algorithms/multisite_hmm/#references","title":"References","text":"<p>Primary: Gold, D.F., Reed, P.M., and Gupta, R.S. (2024). Exploring the spatially compounding multi-sectoral drought vulnerabilities in Colorado's West Slope river basins. Earth's Future. https://doi.org/10.1029/2023EF004126</p> <p>See also: - Rabiner, L.R. (1989). A tutorial on hidden Markov models and selected applications in speech recognition. Proceedings of the IEEE, 77(2), 257-286. - Akintug, B., and Rasmussen, P.F. (2005). A Markov switching model for annual hydrologic time series. Water Resources Research, 41(9).</p> <p>Implementation: <code>src/synhydro/methods/generation/parametric/multisite_hmm.py</code> Tests: <code>tests/test_multisite_hmm_generator.py</code></p>"},{"location":"algorithms/nowak_disaggregation/","title":"Nowak (2010) KNN Temporal Disaggregation","text":"Type Nonparametric Resolution Monthly to Daily Sites Univariate / Multisite Class <code>NowakDisaggregator</code>"},{"location":"algorithms/nowak_disaggregation/#overview","title":"Overview","text":"<p>The Nowak disaggregator converts synthetic monthly flows to daily flows by borrowing within-month daily patterns from the closest historical analogs. For each synthetic month, it identifies the K nearest historic months by total flow, randomly selects one using Lall-Sharma kernel weights, and applies its daily proportions to the synthetic total.</p>"},{"location":"algorithms/nowak_disaggregation/#algorithm","title":"Algorithm","text":""},{"location":"algorithms/nowak_disaggregation/#preprocessing","title":"Preprocessing","text":"<ol> <li>Validate and store daily observed flows.</li> <li>Build historic monthly totals at the index gauge (sum across all sites for multi-site disaggregation).</li> </ol>"},{"location":"algorithms/nowak_disaggregation/#fitting","title":"Fitting","text":"<p>For each calendar month m, fit a <code>sklearn.NearestNeighbors</code> model on the scalar historic monthly totals. Only historic months within +/- <code>max_month_shift</code> calendar days of month m's center are included in the pool.</p>"},{"location":"algorithms/nowak_disaggregation/#disaggregation","title":"Disaggregation","text":"<p>For each synthetic monthly flow <code>Q_syn_m</code>:</p> <ol> <li>Find neighbors \u2014 query the KNN model for the K nearest historic months by Euclidean distance on total flow.</li> <li>Select one neighbor \u2014 draw with probability proportional to <code>1/k</code> (Lall-Sharma kernel, using ranks).</li> <li>Disaggregate \u2014 apply the selected month's daily proportions:    <pre><code>q_d = Q_syn_m * (q*_d / sum(q*_d'))\n</code></pre>    For multi-site data, each site is disaggregated independently using the same selected analog month.</li> </ol>"},{"location":"algorithms/nowak_disaggregation/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>n_neighbors</code> <code>int</code> <code>5</code> K \u2014 number of candidate neighbors <code>max_month_shift</code> <code>int</code> <code>7</code> Days of calendar flexibility around each month"},{"location":"algorithms/nowak_disaggregation/#properties-preserved","title":"Properties Preserved","text":"<ul> <li>Daily flow patterns within each month (borrowed from historical record)</li> <li>Monthly totals (exact, by construction)</li> <li>Multi-site consistency (same analog month applied to all sites)</li> </ul> <p>Not preserved: - Month-to-month daily transitions (each month disaggregated independently) - Daily patterns outside historical range</p>"},{"location":"algorithms/nowak_disaggregation/#limitations","title":"Limitations","text":"<ul> <li>Cannot produce daily patterns not seen in the historical record</li> <li>Leap year handling requires proportional adjustment when analog and target months differ</li> <li>Quality depends on having a sufficiently long historical record to find good analogs</li> </ul>"},{"location":"algorithms/nowak_disaggregation/#references","title":"References","text":"<p>Primary: Nowak, K., Prairie, J., Rajagopalan, B., and Lall, U. (2010). A nonparametric stochastic approach for multisite disaggregation of annual to daily streamflow. Water Resources Research, 46(8). https://doi.org/10.1029/2009WR008530</p> <p>Implementation: <code>src/synhydro/methods/disaggregation/temporal/nowak.py</code> Tests: <code>tests/test_nowak_disaggregator.py</code></p>"},{"location":"algorithms/phase_randomization/","title":"Phase Randomization (Brunner et al. 2019)","text":"Type Nonparametric Resolution Daily Sites Univariate Class <code>PhaseRandomizationGenerator</code>"},{"location":"algorithms/phase_randomization/#overview","title":"Overview","text":"<p>Phase randomization generates synthetic daily streamflow by randomizing the Fourier phase spectrum while preserving the amplitude (power) spectrum. This maintains both short-range (daily autocorrelation) and long-range (Hurst phenomenon) temporal dependence. A four-parameter kappa distribution fitted per day-of-year allows extrapolation beyond the observed range.</p>"},{"location":"algorithms/phase_randomization/#algorithm","title":"Algorithm","text":""},{"location":"algorithms/phase_randomization/#preprocessing","title":"Preprocessing","text":"<ol> <li>Remove leap days \u2014 ensures consistent 365-day years.</li> <li>Create day-of-year index (1\u2013365).</li> <li>Validate \u2014 minimum 730 days (2 complete years), no missing observations.</li> </ol>"},{"location":"algorithms/phase_randomization/#fitting","title":"Fitting","text":"<ol> <li>Marginal distribution fitting (if <code>marginal='kappa'</code>) \u2014 for each day d:</li> <li>Define moving window of +/- <code>win_h_length</code> days (circular, wraps at year boundary)</li> <li>Extract all observations in window across all years</li> <li>Fit four-parameter kappa distribution via L-moment matching</li> <li>Normal score transform \u2014 for each day d:</li> <li>Rank all observations across years</li> <li>Map to standard normal quantiles via rank matching</li> <li>Result: normalized series with N(0,1) marginals per day</li> <li>Fourier transform of normalized series:</li> <li>Compute FFT; extract modulus (amplitude) and phases</li> <li>Store first-half indices and mirror indices for conjugate symmetry</li> </ol>"},{"location":"algorithms/phase_randomization/#generation","title":"Generation","text":"<ol> <li>Phase randomization:</li> <li>Keep DC component (index 0) unchanged</li> <li>For positive frequencies: generate random phases from Uniform(-pi, pi)</li> <li>Construct <code>FT_new[k] = modulus[k] * exp(i * phase_random[k])</code></li> <li>Apply conjugate symmetry for negative frequencies</li> <li>Inverse FFT \u2014 produces phase-randomized series in normalized domain.</li> <li>Back-transform to original distribution \u2014 for each day d:</li> <li>If kappa: generate kappa sample, rank-match against normalized values</li> <li>If empirical: rank-match directly against observed (no extrapolation)</li> <li>Non-negativity \u2014 replace negative values with <code>Uniform(0, min_obs_d)</code>.</li> </ol>"},{"location":"algorithms/phase_randomization/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>marginal</code> <code>str</code> <code>'kappa'</code> Marginal distribution: <code>'kappa'</code> (extrapolation) or <code>'empirical'</code> <code>win_h_length</code> <code>int</code> <code>15</code> Half-window for daily distribution fitting (total = 2*h + 1 days)"},{"location":"algorithms/phase_randomization/#properties-preserved","title":"Properties Preserved","text":"<ul> <li>Full power spectrum (all temporal autocorrelations, in expectation)</li> <li>Long-range dependence (Hurst coefficient)</li> <li>Day-of-year marginal distributions (via kappa or empirical)</li> <li>Seasonal patterns</li> </ul> <p>Not preserved: - Phase coherence (randomized by design) - Exact autocorrelations (preserved only in expectation across ensemble)</p>"},{"location":"algorithms/phase_randomization/#limitations","title":"Limitations","text":"<ul> <li>Univariate only \u2014 no spatial correlations between sites</li> <li>Generated series has same length as observed (no temporal extrapolation)</li> <li>Output excludes February 29 dates</li> <li>Kappa fitting may fail for some days \u2014 falls back to adjacent day parameters</li> <li>Minimum 2 years of data; 10+ recommended for stable kappa fits</li> </ul>"},{"location":"algorithms/phase_randomization/#references","title":"References","text":"<p>Primary: Brunner, M.I., B\u00e1rdossy, A., and Furrer, R. (2019). Technical note: Stochastic simulation of streamflow time series using phase randomization. Hydrology and Earth System Sciences, 23, 3175-3187. https://doi.org/10.5194/hess-23-3175-2019</p> <p>See also: - Theiler, J., Eubank, S., Longtin, A., Galdrikian, B., and Farmer, J.D. (1992). Testing for nonlinearity in time series: the method of surrogate data. Physica D, 58, 77-94. - Hosking, J.R.M. (1990). L-moments: Analysis and estimation of distributions using linear combinations of order statistics. Journal of the Royal Statistical Society Series B, 52, 105-124. - Hosking, J.R.M. (1994). The four-parameter kappa distribution. IBM Journal of Research and Development, 38, 251-258.</p> <p>Implementation: <code>src/synhydro/methods/generation/nonparametric/phase_randomization.py</code> Tests: <code>tests/test_phase_randomization_generator.py</code></p>"},{"location":"algorithms/thomas_fiering/","title":"Thomas-Fiering (1962) with Stedinger-Taylor Normalization","text":"Type Parametric Resolution Monthly Sites Univariate Class <code>ThomasFieringGenerator</code>"},{"location":"algorithms/thomas_fiering/#overview","title":"Overview","text":"<p>The Thomas-Fiering method generates synthetic monthly streamflow using a seasonal AR(1) model with month-specific parameters. The Stedinger-Taylor (1982) normalization applies a lower-bound adjustment before log transformation, reducing skewness and improving the normality assumption. The method preserves monthly means, standard deviations, and lag-1 serial correlations.</p>"},{"location":"algorithms/thomas_fiering/#algorithm","title":"Algorithm","text":""},{"location":"algorithms/thomas_fiering/#preprocessing","title":"Preprocessing","text":"<ol> <li>Resample to monthly if input is daily or sub-monthly (sum within each month).</li> <li>Univariate enforcement \u2014 use first column if multi-site DataFrame is provided.</li> <li>Stedinger-Taylor normalization \u2014 for each month m:</li> <li>Estimate lower bound:      <pre><code>tau_m = (Q_max * Q_min - Q_median^2) / (Q_max + Q_min - 2 * Q_median)\ntau_m = max(tau_m, 0)\n</code></pre></li> <li>Transform: <code>X_m = log(Q_m - tau_m)</code></li> </ol>"},{"location":"algorithms/thomas_fiering/#fitting","title":"Fitting","text":"<ol> <li>Monthly statistics \u2014 for each month m, compute from transformed flows X:</li> <li>Mean: <code>mu_m</code></li> <li>Standard deviation: <code>sigma_m</code></li> <li>Lag-1 serial correlations \u2014 for each transition m to m+1:</li> <li><code>rho_m = corr(X_m, X_{m+1})</code> (Dec-Jan wraps across year boundary)</li> <li>Store parameters \u2014 48 total (12 months x 4: mu, sigma, rho, tau).</li> </ol>"},{"location":"algorithms/thomas_fiering/#generation","title":"Generation","text":"<ol> <li>Initialize first month: <code>X_1 = mu_1 + epsilon * sigma_1</code> where <code>epsilon ~ N(0,1)</code>.</li> <li>AR(1) recursion for each subsequent month:    <pre><code>X_m = mu_m + rho_m * (sigma_m / sigma_{m-1}) * (X_{m-1} - mu_{m-1})\n      + sqrt(1 - rho_m^2) * sigma_m * epsilon\n</code></pre></li> <li>Inverse transform: <code>Q_m = exp(X_m) + tau_m</code></li> <li>Non-negativity: clip to observed monthly minimum.</li> </ol>"},{"location":"algorithms/thomas_fiering/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>Q_obs</code> <code>pd.DataFrame</code> \u2014 Observed streamflow with DatetimeIndex <code>debug</code> <code>bool</code> <code>False</code> Enable debug logging"},{"location":"algorithms/thomas_fiering/#properties-preserved","title":"Properties Preserved","text":"<ul> <li>Monthly means and standard deviations (in transformed space)</li> <li>Lag-1 serial correlation (month-to-month)</li> <li>Seasonal flow patterns (via month-specific parameters)</li> </ul> <p>Not preserved: - Higher-order autocorrelation (lag &gt; 1) - Spatial correlations (univariate method) - Exact marginal distributions (normality imposed via transformation)</p>"},{"location":"algorithms/thomas_fiering/#limitations","title":"Limitations","text":"<ul> <li>Univariate only \u2014 no spatial correlation modeling</li> <li>First-order memory \u2014 misses multi-month drought persistence</li> <li>Requires at least 2 complete years; 10+ recommended</li> <li>Assumes stationarity (no trends or regime shifts)</li> </ul>"},{"location":"algorithms/thomas_fiering/#references","title":"References","text":"<p>Primary: Thomas, H.A., and Fiering, M.B. (1962). Mathematical synthesis of streamflow sequences for the analysis of river basins by simulation. In Design of Water Resource Systems (eds. Maass et al.), pp. 459-493. Harvard University Press.</p> <p>See also: - Stedinger, J.R., and Taylor, M.R. (1982). Synthetic streamflow generation: 1. Model verification and validation. Water Resources Research, 18(4), 909-918. https://doi.org/10.1029/WR018i004p00909</p> <p>Implementation: <code>src/synhydro/methods/generation/parametric/thomas_fiering.py</code> Tests: <code>tests/test_thomas_fiering_generator.py</code></p>"},{"location":"algorithms/warm/","title":"WARM \u2014 Wavelet Auto-Regressive Method (Nowak et al. 2011)","text":"Type Parametric Resolution Annual Sites Univariate Class <code>WARMGenerator</code>"},{"location":"algorithms/warm/#overview","title":"Overview","text":"<p>WARM combines continuous wavelet transforms with autoregressive modeling to generate synthetic annual streamflow. Its key innovation is the Scale Averaged Wavelet Power (SAWP), which captures time-varying spectral characteristics. This makes WARM particularly suited for non-stationary flows with regime shifts or low-frequency variability (e.g., climate oscillations, multi-decadal droughts).</p>"},{"location":"algorithms/warm/#algorithm","title":"Algorithm","text":""},{"location":"algorithms/warm/#preprocessing","title":"Preprocessing","text":"<ol> <li>Validate input (univariate time series, minimum ~20 years recommended).</li> <li>Resample to annual frequency if needed (sum monthly or daily).</li> </ol>"},{"location":"algorithms/warm/#fitting","title":"Fitting","text":"<ol> <li> <p>Continuous Wavelet Transform \u2014 decompose observed flows into time-frequency components using mother wavelet (default: Morlet):    <pre><code>W(s, t) = CWT(Q_obs, scales, wavelet)\n</code></pre>    Result: coefficient matrix of shape (n_scales, n_years).</p> </li> <li> <p>Scale Averaged Wavelet Power \u2014 compute time-varying power across all scales:    <pre><code>SAWP(t) = (1/S) * sum_s |W(s, t)|^2\n</code></pre>    High SAWP indicates high energy/variability at time t.</p> </li> <li> <p>Normalize by SAWP \u2014 remove time-varying power to produce stationary components:    <pre><code>W_norm(s, t) = W(s, t) / sqrt(SAWP(t) + epsilon)\n</code></pre></p> </li> <li> <p>Fit AR models \u2014 for each scale s, fit an AR(p) model to normalized coefficients via Yule-Walker equations. Store parameters: mean, AR coefficients, innovation variance.</p> </li> </ol>"},{"location":"algorithms/warm/#generation","title":"Generation","text":"<ol> <li>Generate normalized coefficients \u2014 for each scale, run the fitted AR(p) process forward with Gaussian innovations.</li> <li>Resample SAWP \u2014 bootstrap SAWP values from the historical record with replacement.</li> <li>Rescale coefficients \u2014 restore time-varying power:    <pre><code>W_syn(s, t) = W_norm_syn(s, t) * sqrt(SAWP_syn(t) + epsilon)\n</code></pre></li> <li>Inverse wavelet transform \u2014 reconstruct streamflow via weighted summation across scales. Adjust mean and variance to match observed, then clip negatives to zero.</li> </ol>"},{"location":"algorithms/warm/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>wavelet</code> <code>str</code> <code>'morl'</code> Mother wavelet (Morlet recommended for hydrology) <code>scales</code> <code>int</code> <code>64</code> Number of frequency scales (rule of thumb: T/2 to T) <code>ar_order</code> <code>int</code> <code>1</code> AR model order (1 or 2 typically sufficient)"},{"location":"algorithms/warm/#properties-preserved","title":"Properties Preserved","text":"<ul> <li>Mean and variance (exactly, via post-reconstruction adjustment)</li> <li>Lag-1 autocorrelation (approximately, via AR models)</li> <li>Multi-year persistence and low-frequency variability (via wavelet decomposition)</li> <li>Non-stationary variance structure (via SAWP)</li> <li>Power spectrum (via wavelet amplitude preservation)</li> </ul> <p>Not preserved: - Exact marginal distribution shape (Gaussian innovations) - Skewness and higher moments (not explicitly modeled) - Spatial correlations (univariate method)</p>"},{"location":"algorithms/warm/#limitations","title":"Limitations","text":"<ul> <li>Annual frequency only \u2014 for finer resolution, couple with a disaggregation method</li> <li>Univariate (single site) \u2014 no native multi-site support</li> <li>Inverse CWT is approximate (PyWavelets); corrected by mean/variance adjustment</li> <li>Edge effects in CWT for short records (&lt; 20 years)</li> <li>Gaussian AR innovations may underrepresent extremes</li> </ul>"},{"location":"algorithms/warm/#references","title":"References","text":"<p>Primary: Nowak, K., Rajagopalan, B., and Zagona, E. (2011). A Wavelet Auto-Regressive Method (WARM) for multi-site streamflow simulation of data with non-stationary trends. Journal of Hydrology, 410(1-2), 1-12. https://doi.org/10.1016/j.jhydrol.2011.08.049</p> <p>See also: - Kwon, H.-H., Lall, U., and Khalil, A.F. (2007). Stochastic simulation model for nonstationary time series using an autoregressive wavelet decomposition. Water Resources Research, 43(5). - Torrence, C., and Compo, G.P. (1998). A practical guide to wavelet analysis. Bulletin of the American Meteorological Society, 79(1), 61-78.</p> <p>Implementation: <code>src/synhydro/methods/generation/parametric/warm.py</code> Tests: <code>tests/test_warm_generator.py</code></p>"},{"location":"api/core/","title":"Core Data Structures","text":""},{"location":"api/core/#ensemble","title":"Ensemble","text":""},{"location":"api/core/#synhydro.core.ensemble.Ensemble","title":"Ensemble","text":"<pre><code>Ensemble(data: Dict[Union[int, str], DataFrame], metadata: Optional[EnsembleMetadata] = None)\n</code></pre> <p>Manage ensemble timeseries data with dual representations.</p> <p>The Ensemble class stores synthetic timeseries data in two complementary formats:</p> <ol> <li>By Realization: <code>{realization_id: DataFrame[sites \u00d7 time]}</code></li> <li>Keys are realization numbers (int)</li> <li> <p>Values are DataFrames with sites as columns</p> </li> <li> <p>By Site: <code>{site_name: DataFrame[realizations \u00d7 time]}</code></p> </li> <li>Keys are site names (str)</li> <li>Values are DataFrames with realizations as columns</li> </ol> <p>Both representations are maintained automatically and provide efficient access for different analysis workflows.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[Union[int, str], DataFrame]</code> <p>Ensemble data in either format. Structure is automatically detected.</p> required <code>metadata</code> <code>EnsembleMetadata</code> <p>Metadata about the ensemble. If None, creates default metadata.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>data_by_realization</code> <code>Dict[int, DataFrame]</code> <p>Data organized by realization number.</p> <code>data_by_site</code> <code>Dict[str, DataFrame]</code> <p>Data organized by site name.</p> <code>realization_ids</code> <code>List[int]</code> <p>List of all realization IDs.</p> <code>site_names</code> <code>List[str]</code> <p>List of all site names.</p> <code>metadata</code> <code>EnsembleMetadata</code> <p>Ensemble metadata and provenance information.</p> <p>Examples:</p> <p>Create ensemble from generator output:</p> <pre><code>&gt;&gt;&gt; from synhydro import ThomasFieringGenerator, Ensemble\n&gt;&gt;&gt; gen = ThomasFieringGenerator(Q_hist)\n&gt;&gt;&gt; gen.fit()\n&gt;&gt;&gt; Q_syn = gen.generate(n_years=50, n_realizations=100)\n&gt;&gt;&gt; ensemble = Ensemble.from_generator(gen, n_years=50, n_realizations=100)\n</code></pre> <p>Save and load ensemble:</p> <pre><code>&gt;&gt;&gt; ensemble.to_hdf5('synthetic_flows.h5')\n&gt;&gt;&gt; ensemble_loaded = Ensemble.from_hdf5('synthetic_flows.h5')\n</code></pre> <p>Access data by site or realization:</p> <pre><code>&gt;&gt;&gt; site_data = ensemble.data_by_site['site_A']  # All realizations for site A\n&gt;&gt;&gt; real_data = ensemble.data_by_realization[0]  # All sites for realization 0\n</code></pre> <p>Compute statistics:</p> <pre><code>&gt;&gt;&gt; stats = ensemble.summary(by='site')\n&gt;&gt;&gt; percentiles = ensemble.percentile([10, 50, 90], by='site')\n</code></pre> <p>Initialize Ensemble with data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[Union[int, str], DataFrame]</code> <p>Ensemble data dictionary. Structure is auto-detected.</p> required <code>metadata</code> <code>EnsembleMetadata</code> <p>Metadata about the ensemble.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If data is not a dictionary.</p> <code>ValueError</code> <p>If data structure cannot be determined.</p>"},{"location":"api/core/#synhydro.core.ensemble.Ensemble.frequency","title":"frequency  <code>property</code>","text":"<pre><code>frequency: Optional[str]\n</code></pre> <p>Get the time frequency/resolution of the ensemble data.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Time frequency (e.g., 'D', 'MS', 'YS') from metadata.</p>"},{"location":"api/core/#synhydro.core.ensemble.Ensemble.sites","title":"sites  <code>property</code>","text":"<pre><code>sites: List[str]\n</code></pre> <p>Get list of site names (alias for site_names).</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of site names in the ensemble.</p>"},{"location":"api/core/#synhydro.core.ensemble.Ensemble.from_hdf5","title":"from_hdf5  <code>classmethod</code>","text":"<pre><code>from_hdf5(filename: str, realization_subset: Optional[List[int]] = None, stored_by_node: bool = True) -&gt; Ensemble\n</code></pre> <p>Load ensemble from HDF5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to HDF5 file.</p> required <code>realization_subset</code> <code>List[int]</code> <p>Load only specified realizations. If None, loads all.</p> <code>None</code> <code>stored_by_node</code> <code>bool</code> <p>If True, data is stored with sites as top-level groups.</p> <code>True</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Loaded ensemble object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ensemble = Ensemble.from_hdf5('synthetic_flows.h5')\n&gt;&gt;&gt; ensemble = Ensemble.from_hdf5('flows.h5', realization_subset=[0, 1, 2])\n</code></pre>"},{"location":"api/core/#synhydro.core.ensemble.Ensemble.to_hdf5","title":"to_hdf5","text":"<pre><code>to_hdf5(filename: str, compression: Optional[str] = 'gzip', stored_by_node: bool = True)\n</code></pre> <p>Save ensemble to HDF5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to output HDF5 file.</p> required <code>compression</code> <code>str</code> <p>Compression algorithm ('gzip', 'lzf', None). Default is 'gzip'.</p> <code>'gzip'</code> <code>stored_by_node</code> <code>bool</code> <p>If True, store data with sites as top-level groups.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ensemble.to_hdf5('synthetic_flows.h5')\n&gt;&gt;&gt; ensemble.to_hdf5('flows.h5', compression='lzf')\n</code></pre>"},{"location":"api/core/#synhydro.core.ensemble.Ensemble.from_generator","title":"from_generator  <code>classmethod</code>","text":"<pre><code>from_generator(generator, n_years: int, n_realizations: int, **gen_kwargs) -&gt; Ensemble\n</code></pre> <p>Create ensemble directly from a fitted Generator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>Generator</code> <p>A fitted generator instance.</p> required <code>n_years</code> <code>int</code> <p>Number of years to generate.</p> required <code>n_realizations</code> <code>int</code> <p>Number of realizations to generate.</p> required <code>**gen_kwargs</code> <p>Additional keyword arguments passed to generator.generate().</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>New ensemble with metadata from generator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from synhydro import ThomasFieringGenerator, Ensemble\n&gt;&gt;&gt; gen = ThomasFieringGenerator(Q_hist)\n&gt;&gt;&gt; gen.fit()\n&gt;&gt;&gt; ensemble = Ensemble.from_generator(gen, n_years=50, n_realizations=100)\n</code></pre>"},{"location":"api/core/#synhydro.core.ensemble.Ensemble.summary","title":"summary","text":"<pre><code>summary(by: str = 'site') -&gt; pd.DataFrame\n</code></pre> <p>Compute statistical summary across realizations or sites.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>(site, realization)</code> <p>Compute statistics by site or by realization.</p> <code>'site'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Summary statistics (mean, std, min, max) for each site or realization.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stats = ensemble.summary(by='site')\n&gt;&gt;&gt; print(stats)\n</code></pre>"},{"location":"api/core/#synhydro.core.ensemble.Ensemble.percentile","title":"percentile","text":"<pre><code>percentile(q: Union[float, List[float]], by: str = 'site') -&gt; Dict[str, pd.DataFrame]\n</code></pre> <p>Compute percentiles across realizations.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>float or List[float]</code> <p>Percentile(s) to compute (0-100).</p> required <code>by</code> <code>(site, realization)</code> <p>Compute percentiles by site or realization.</p> <code>'site'</code> <p>Returns:</p> Type Description <code>Dict[str, DataFrame]</code> <p>Dictionary mapping site/realization to DataFrame of percentiles over time.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; p = ensemble.percentile([10, 50, 90], by='site')\n&gt;&gt;&gt; site_a_percentiles = p['site_A']\n</code></pre>"},{"location":"api/core/#synhydro.core.ensemble.Ensemble.subset","title":"subset","text":"<pre><code>subset(sites: Optional[List[str]] = None, realizations: Optional[List[int]] = None, start_date: Optional[str] = None, end_date: Optional[str] = None) -&gt; Ensemble\n</code></pre> <p>Create subset of ensemble by sites, realizations, or time period.</p> <p>Parameters:</p> Name Type Description Default <code>sites</code> <code>List[str]</code> <p>Site names to include.</p> <code>None</code> <code>realizations</code> <code>List[int]</code> <p>Realization IDs to include.</p> <code>None</code> <code>start_date</code> <code>str</code> <p>Start date (ISO format or pandas-parseable).</p> <code>None</code> <code>end_date</code> <code>str</code> <p>End date (ISO format or pandas-parseable).</p> <code>None</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>New ensemble containing only the subset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; subset = ensemble.subset(sites=['site_A', 'site_B'],\n...                          start_date='2000-01-01',\n...                          end_date='2010-12-31')\n</code></pre>"},{"location":"api/core/#synhydro.core.ensemble.Ensemble.resample","title":"resample","text":"<pre><code>resample(freq: str) -&gt; Ensemble\n</code></pre> <p>Resample time series to different frequency.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>str</code> <p>Pandas frequency string ('D', 'W', 'MS', 'AS', etc.).</p> required <p>Returns:</p> Type Description <code>Ensemble</code> <p>New ensemble with resampled data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; monthly_ensemble = daily_ensemble.resample('MS')\n</code></pre>"},{"location":"api/core/#ensemblemetadata","title":"EnsembleMetadata","text":""},{"location":"api/core/#synhydro.core.ensemble.EnsembleMetadata","title":"EnsembleMetadata  <code>dataclass</code>","text":"<pre><code>EnsembleMetadata(generator_class: Optional[str] = None, generator_params: Optional[Dict[str, Any]] = None, creation_timestamp: str = (lambda: datetime.now().isoformat())(), n_realizations: int = 0, n_sites: int = 0, time_resolution: Optional[str] = None, time_period: Optional[Tuple[str, str]] = None, description: Optional[str] = None, custom_attrs: Optional[Dict[str, Any]] = dict())\n</code></pre> <p>Store metadata about an ensemble.</p> <p>Attributes:</p> Name Type Description <code>generator_class</code> <code>(str, optional)</code> <p>Name of the generator class that created this ensemble.</p> <code>generator_params</code> <code>(Dict, optional)</code> <p>Parameters used to configure the generator.</p> <code>creation_timestamp</code> <code>str</code> <p>ISO format timestamp of when ensemble was created.</p> <code>n_realizations</code> <code>int</code> <p>Number of realizations in the ensemble.</p> <code>n_sites</code> <code>int</code> <p>Number of sites/locations in the ensemble.</p> <code>time_resolution</code> <code>(str, optional)</code> <p>Time resolution of data ('daily', 'monthly', etc.).</p> <code>time_period</code> <code>(Tuple[str, str], optional)</code> <p>Start and end dates of time series (ISO format strings).</p> <code>description</code> <code>(str, optional)</code> <p>User-provided description of the ensemble.</p> <code>custom_attrs</code> <code>(Dict, optional)</code> <p>Additional user-defined metadata attributes.</p>"},{"location":"api/core/#synhydro.core.ensemble.EnsembleMetadata.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert metadata to dictionary.</p>"},{"location":"api/core/#parameter-containers","title":"Parameter Containers","text":""},{"location":"api/core/#synhydro.core.base.FittedParams","title":"FittedParams  <code>dataclass</code>","text":"<pre><code>FittedParams(means_: Optional[Union[Series, DataFrame]] = None, stds_: Optional[Union[Series, DataFrame]] = None, correlations_: Optional[Union[ndarray, Dict[str, ndarray]]] = None, distributions_: Optional[Dict[str, Any]] = None, transformations_: Optional[Dict[str, Any]] = None, fitted_models_: Optional[Dict[str, Any]] = None, n_parameters_: int = 0, sample_size_: int = 0, n_sites_: int = 0, training_period_: Optional[Tuple[str, str]] = None)\n</code></pre> <p>Store parameters learned from data during fit().</p> <p>Following scikit-learn convention, parameter names end with underscore.</p>"},{"location":"api/core/#synhydro.core.base.FittedParams.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert to dictionary, handling numpy/pandas types.</p>"},{"location":"api/core/#synhydro.core.base.GeneratorState","title":"GeneratorState  <code>dataclass</code>","text":"<pre><code>GeneratorState(is_preprocessed: bool = False, is_fitted: bool = False, preprocessing_params: Dict[str, Any] = dict(), fit_params: Dict[str, Any] = dict(), fit_timestamp: Optional[str] = None)\n</code></pre> <p>Track generator preprocessing and fitting state.</p>"},{"location":"api/core/#synhydro.core.base.GeneratorParams","title":"GeneratorParams  <code>dataclass</code>","text":"<pre><code>GeneratorParams(random_seed: Optional[int] = None, verbose: bool = False, debug: bool = False, algorithm_params: Dict[str, Any] = dict(), transformation_params: Dict[str, Any] = dict(), computational_params: Dict[str, Any] = dict())\n</code></pre> <p>Store initialization/configuration parameters for generators.</p> <p>These are user-specified settings that control algorithm behavior, not learned from data.</p>"},{"location":"api/core/#synhydro.core.base.GeneratorParams.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Convert to flat dictionary.</p>"},{"location":"api/disaggregators/","title":"Disaggregators &amp; Pipelines","text":""},{"location":"api/disaggregators/#base-class","title":"Base Class","text":""},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator","title":"Disaggregator","text":"<pre><code>Disaggregator(Q_obs: Union[Series, DataFrame], name: Optional[str] = None, debug: bool = False)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for all temporal disaggregation methods.</p> <p>Disaggregators transform synthetic flows from one temporal resolution to a finer resolution (e.g., monthly to daily).</p> <p>All disaggregator implementations should inherit from this class.</p> <p>Initialize the disaggregator base class.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>Series or DataFrame</code> <p>Observed historical flow data used to train disaggregation patterns. Should be at the finer temporal resolution (output resolution).</p> required <code>name</code> <code>str</code> <p>Name identifier for this disaggregator instance</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging</p> <code>False</code>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.is_fitted","title":"is_fitted  <code>property</code>","text":"<pre><code>is_fitted: bool\n</code></pre> <p>Check if disaggregator is fitted.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.is_preprocessed","title":"is_preprocessed  <code>property</code>","text":"<pre><code>is_preprocessed: bool\n</code></pre> <p>Check if preprocessing is complete.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites: int\n</code></pre> <p>Number of sites in the disaggregator.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of sites.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If preprocessing not yet run.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.sites","title":"sites  <code>property</code>","text":"<pre><code>sites: List[str]\n</code></pre> <p>List of site names.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>Site identifiers.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If preprocessing not yet run.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.input_frequency","title":"input_frequency  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>input_frequency: str\n</code></pre> <p>Expected temporal frequency of input ensemble.</p> <p>Returns:</p> Type Description <code>str</code> <p>Pandas frequency string (e.g., 'MS' for monthly, 'W' for weekly).</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.output_frequency","title":"output_frequency  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>output_frequency: str\n</code></pre> <p>Temporal frequency of disaggregated output.</p> <p>Returns:</p> Type Description <code>str</code> <p>Pandas frequency string (e.g., 'D' for daily, 'H' for hourly).</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.validate_input_data","title":"validate_input_data","text":"<pre><code>validate_input_data(data: Union[Series, DataFrame]) -&gt; pd.DataFrame\n</code></pre> <p>Validate and standardize input data format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Series or DataFrame</code> <p>Input time series data</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Validated and standardized data</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data format is invalid</p> <code>TypeError</code> <p>If data type is unsupported</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.validate_preprocessing","title":"validate_preprocessing","text":"<pre><code>validate_preprocessing() -&gt; None\n</code></pre> <p>Check if preprocessing has been completed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If preprocessing() has not been run.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.validate_fit","title":"validate_fit","text":"<pre><code>validate_fit() -&gt; None\n</code></pre> <p>Check if disaggregator has been fitted.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fit() has not been run.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.update_state","title":"update_state","text":"<pre><code>update_state(preprocessed: Optional[bool] = None, fitted: Optional[bool] = None) -&gt; None\n</code></pre> <p>Update disaggregator state flags.</p> <p>Parameters:</p> Name Type Description Default <code>preprocessed</code> <code>bool</code> <p>Set preprocessing state.</p> <code>None</code> <code>fitted</code> <code>bool</code> <p>Set fitted state.</p> <code>None</code>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.validate_input_ensemble","title":"validate_input_ensemble","text":"<pre><code>validate_input_ensemble(ensemble: Ensemble) -&gt; None\n</code></pre> <p>Validate that input ensemble is compatible with disaggregator.</p> <p>Checks temporal frequency and site consistency.</p> <p>Parameters:</p> Name Type Description Default <code>ensemble</code> <code>Ensemble</code> <p>Input ensemble to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If ensemble is incompatible with disaggregator</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.get_params","title":"get_params","text":"<pre><code>get_params(deep: bool = True) -&gt; Dict[str, Any]\n</code></pre> <p>Get initialization parameters (scikit-learn style).</p> <p>Returns only constructor/configuration parameters, not fitted values.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True, return deep copy of parameters.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of initialization parameters.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.get_fitted_params","title":"get_fitted_params","text":"<pre><code>get_fitted_params() -&gt; Dict[str, Any]\n</code></pre> <p>Get parameters learned from data during fit().</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of fitted parameters (all keys end with underscore).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If disaggregator has not been fitted yet.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.summary","title":"summary","text":"<pre><code>summary(show_fitted: bool = True) -&gt; str\n</code></pre> <p>Generate comprehensive summary of disaggregator configuration and fit.</p> <p>Parameters:</p> Name Type Description Default <code>show_fitted</code> <code>bool</code> <p>Whether to include fitted parameters in summary.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted summary string.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.save","title":"save","text":"<pre><code>save(filepath: str) -&gt; None\n</code></pre> <p>Save fitted disaggregator to file using pickle.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to save the disaggregator.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If disaggregator is not fitted.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(filepath: str) -&gt; Disaggregator\n</code></pre> <p>Load fitted disaggregator from file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to saved disaggregator file.</p> required <p>Returns:</p> Type Description <code>Disaggregator</code> <p>Loaded disaggregator instance.</p>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.preprocessing","title":"preprocessing  <code>abstractmethod</code>","text":"<pre><code>preprocessing(**kwargs: Any) -&gt; None\n</code></pre> <p>Preprocess and validate observed flow data.</p> <p>Implementations should: 1. Call validate_input_data() to validate self._Q_obs_raw 2. Store preprocessed data as instance attributes 3. Call update_state(preprocessed=True) at end</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional preprocessing parameters.</p> <code>{}</code>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.fit","title":"fit  <code>abstractmethod</code>","text":"<pre><code>fit(**kwargs: Any) -&gt; None\n</code></pre> <p>Fit the disaggregator to observed flow data.</p> <p>Implementations should: 1. Call validate_preprocessing() at start 2. Learn disaggregation patterns from historic data 3. Store fitted parameters as instance attributes 4. Call update_state(fitted=True) at end</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional fitting parameters.</p> <code>{}</code>"},{"location":"api/disaggregators/#synhydro.core.base.Disaggregator.disaggregate","title":"disaggregate  <code>abstractmethod</code>","text":"<pre><code>disaggregate(ensemble: Ensemble, **kwargs: Any) -&gt; Ensemble\n</code></pre> <p>Disaggregate synthetic flows from coarser to finer temporal resolution.</p> <p>Implementations should: 1. Call validate_fit() at start 2. Call validate_input_ensemble() to check compatibility 3. Disaggregate each realization in the ensemble 4. Return new Ensemble with finer temporal resolution</p> <p>Parameters:</p> Name Type Description Default <code>ensemble</code> <code>Ensemble</code> <p>Input ensemble at coarser temporal resolution</p> required <code>**kwargs</code> <code>Any</code> <p>Additional disaggregation parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Disaggregated ensemble at finer temporal resolution</p>"},{"location":"api/disaggregators/#nowakdisaggregator","title":"NowakDisaggregator","text":""},{"location":"api/disaggregators/#synhydro.methods.disaggregation.temporal.nowak.NowakDisaggregator","title":"NowakDisaggregator","text":"<pre><code>NowakDisaggregator(Q_obs, n_neighbors=5, max_month_shift=7, name=None, debug=False)\n</code></pre> <p>               Bases: <code>Disaggregator</code></p> <p>Temporal disaggregation from monthly to daily as described in Nowak et al. (2010).</p> <p>Supports both single-site and multisite disaggregation from monthly to daily streamflows.</p> <p>For each month in synthetic data, finds the N historic monthly flow profiles which have similar total flow at the index gauge (sum of all sites).</p> <p>Then, randomly selects one of the N profiles and uses the daily flow proportions from that month to disaggregate the synthetic monthly flow at all sites.</p> <p>When disaggregating a month, only considers historic profiles from the same month of interest, with +/- max_month_shift days around each month.</p> References <p>Nowak, K., Prairie, J., Rajagopalan, B., &amp; Lall, U. (2010). A nonparametric stochastic approach for multisite disaggregation of annual to daily streamflow. Water Resources Research, 46(8).</p> <p>Initialize the Nowak Disaggregator.</p> <p>Supports both single site (Series) and multi-site (DataFrame) disaggregation.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>Series or DataFrame</code> <p>Daily streamflow data for the historic period. Must have DatetimeIndex with daily frequency. If DataFrame, columns represent different sites.</p> required <code>n_neighbors</code> <code>int</code> <p>Number of K-nearest neighbors to consider for disaggregation.</p> <code>5</code> <code>max_month_shift</code> <code>int</code> <p>Maximum number of days to shift around each month center when creating historic monthly flow profiles.</p> <code>7</code> <code>name</code> <code>str</code> <p>Name for this disaggregator instance.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code>"},{"location":"api/disaggregators/#synhydro.methods.disaggregation.temporal.nowak.NowakDisaggregator.input_frequency","title":"input_frequency  <code>property</code>","text":"<pre><code>input_frequency: str\n</code></pre> <p>Nowak disaggregator expects monthly input.</p>"},{"location":"api/disaggregators/#synhydro.methods.disaggregation.temporal.nowak.NowakDisaggregator.output_frequency","title":"output_frequency  <code>property</code>","text":"<pre><code>output_frequency: str\n</code></pre> <p>Nowak disaggregator produces daily output.</p>"},{"location":"api/disaggregators/#synhydro.methods.disaggregation.temporal.nowak.NowakDisaggregator.preprocessing","title":"preprocessing","text":"<pre><code>preprocessing(**kwargs)\n</code></pre> <p>Preprocess observed daily flow data.</p> <p>Validates input data and detects single-site vs multisite configuration.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional preprocessing parameters (currently unused).</p> <code>{}</code>"},{"location":"api/disaggregators/#synhydro.methods.disaggregation.temporal.nowak.NowakDisaggregator.fit","title":"fit","text":"<pre><code>fit(**kwargs)\n</code></pre> <p>Fit the Nowak Disaggregator to the data.</p> <p>Creates a dataset of candidate monthly flow profiles for each month, and trains KNN models for each month.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional fitting parameters (currently unused).</p> <code>{}</code>"},{"location":"api/disaggregators/#synhydro.methods.disaggregation.temporal.nowak.NowakDisaggregator.disaggregate","title":"disaggregate","text":"<pre><code>disaggregate(ensemble: Ensemble, n_neighbors=None, sample_method='distance_weighted', **kwargs) -&gt; Ensemble\n</code></pre> <p>Disaggregate monthly ensemble to daily flows using the Nowak method.</p> <p>Parameters:</p> Name Type Description Default <code>ensemble</code> <code>Ensemble</code> <p>Monthly streamflow ensemble to disaggregate. Must have frequency 'MS' (monthly start).</p> required <code>n_neighbors</code> <code>int</code> <p>Number of neighbors to use for disaggregation. If None, uses the value from initialization.</p> <code>None</code> <code>sample_method</code> <code>str</code> <p>Method to use for sampling the K nearest neighbors.</p> <code>'distance_weighted'</code> <code>**kwargs</code> <p>Additional disaggregation parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Disaggregated daily streamflow ensemble.</p>"},{"location":"api/disaggregators/#synhydro.methods.disaggregation.temporal.nowak.NowakDisaggregator.find_knn_indices","title":"find_knn_indices","text":"<pre><code>find_knn_indices(Qs_monthly_array, month, n_neighbors=None)\n</code></pre> <p>Given cumulative monthly flow values, find the K nearest neighbors from the historic dataset.</p> <p>Parameters:</p> Name Type Description Default <code>Qs_monthly_array</code> <code>array</code> <p>The cumulative monthly flow values for the month to disaggregate.</p> required <code>month</code> <code>int</code> <p>The calendar month which is being disaggregated (1-12).</p> required <code>n_neighbors</code> <code>int</code> <p>The number of neighbors to find.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>distances</code> <code>array</code> <p>The distances to the K nearest neighbors.</p> <code>indices</code> <code>array</code> <p>The indices of the K nearest neighbors in the historic dataset.</p>"},{"location":"api/disaggregators/#synhydro.methods.disaggregation.temporal.nowak.NowakDisaggregator.sample_knn_monthly_flows","title":"sample_knn_monthly_flows","text":"<pre><code>sample_knn_monthly_flows(Qs_monthly_array, month, n_neighbors=None, sample_method='distance_weighted')\n</code></pre> <p>Given cumulative monthly flow values, sample K nearest neighbors from the historic dataset.</p> <p>Parameters:</p> Name Type Description Default <code>Qs_monthly_array</code> <code>array</code> <p>The cumulative monthly flow values for the month to disaggregate.</p> required <code>month</code> <code>int</code> <p>The calendar month which is being disaggregated (1-12).</p> required <code>n_neighbors</code> <code>int</code> <p>The number of neighbors to sample.</p> <code>None</code> <code>sample_method</code> <code>str</code> <p>The sampling method to use.</p> <code>'distance_weighted'</code> <p>Returns:</p> Name Type Description <code>sampled_indices</code> <code>array</code> <p>The sampled indices from the historic dataset.</p>"},{"location":"api/disaggregators/#synhydro.methods.disaggregation.temporal.nowak.NowakDisaggregator.disaggregate_monthly_flows","title":"disaggregate_monthly_flows","text":"<pre><code>disaggregate_monthly_flows(Qs_monthly, n_neighbors=None, sample_method='distance_weighted')\n</code></pre> <p>Disaggregate monthly to daily flows using the Nowak method.</p> <p>Parameters:</p> Name Type Description Default <code>Qs_monthly</code> <code>Series or DataFrame</code> <p>Monthly streamflow data for the synthetic period.  The index should be a datetime index. For multisite, should be DataFrame with same columns as historic data.</p> required <code>n_neighbors</code> <code>int</code> <p>The number of neighbors to use for disaggregation.</p> <code>None</code> <code>sample_method</code> <code>str</code> <p>The method to use for sampling the K nearest neighbors.</p> <code>'distance_weighted'</code> <p>Returns:</p> Name Type Description <code>Qs_daily</code> <code>Series or DataFrame</code> <p>Daily streamflow data for the synthetic period.  The index will be a datetime index. For multisite, returns DataFrame with same columns as input.</p>"},{"location":"api/disaggregators/#pipelines","title":"Pipelines","text":""},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline","title":"GeneratorDisaggregatorPipeline","text":"<pre><code>GeneratorDisaggregatorPipeline(generator: Generator, disaggregator: Disaggregator, name: Optional[str] = None, debug: bool = False)\n</code></pre> <p>Pipeline for composing a generator with a disaggregator.</p> <p>This class orchestrates the flow from generation to disaggregation, ensuring compatibility between components and managing the complete workflow.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>Generator</code> <p>A fitted or unfitted generator instance.</p> required <code>disaggregator</code> <code>Disaggregator</code> <p>A fitted or unfitted disaggregator instance.</p> required <code>name</code> <code>str</code> <p>Name for this pipeline instance.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from synhydro.methods.generate.nonparametric.kirsch import KirschGenerator\n&gt;&gt;&gt; from synhydro.methods.disaggregate.temporal.nowak import NowakDisaggregator\n&gt;&gt;&gt; from synhydro.core.pipeline import GeneratorDisaggregatorPipeline\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create components\n&gt;&gt;&gt; generator = KirschGenerator(Q_daily)\n&gt;&gt;&gt; disaggregator = NowakDisaggregator(Q_daily)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create pipeline\n&gt;&gt;&gt; pipeline = GeneratorDisaggregatorPipeline(generator, disaggregator)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Fit and generate\n&gt;&gt;&gt; pipeline.preprocessing()\n&gt;&gt;&gt; pipeline.fit()\n&gt;&gt;&gt; daily_ensemble = pipeline.generate(n_realizations=10, n_years=50)\n</code></pre> <p>Initialize the pipeline with generator and disaggregator components.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>Generator</code> <p>Generator instance for producing synthetic flows.</p> required <code>disaggregator</code> <code>Disaggregator</code> <p>Disaggregator instance for temporal disaggregation.</p> required <code>name</code> <code>str</code> <p>Name for this pipeline.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If components are not proper Generator/Disaggregator instances.</p> <code>ValueError</code> <p>If generator output frequency doesn't match disaggregator input frequency.</p>"},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline.is_preprocessed","title":"is_preprocessed  <code>property</code>","text":"<pre><code>is_preprocessed: bool\n</code></pre> <p>Check if both components are preprocessed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if both generator and disaggregator are preprocessed.</p>"},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline.is_fitted","title":"is_fitted  <code>property</code>","text":"<pre><code>is_fitted: bool\n</code></pre> <p>Check if both components are fitted.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if both generator and disaggregator are fitted.</p>"},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline.output_frequency","title":"output_frequency  <code>property</code>","text":"<pre><code>output_frequency: str\n</code></pre> <p>Get the final output frequency of the pipeline.</p> <p>Returns:</p> Type Description <code>str</code> <p>Pandas frequency string (e.g., 'D' for daily).</p>"},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline.validate_compatibility","title":"validate_compatibility","text":"<pre><code>validate_compatibility() -&gt; None\n</code></pre> <p>Validate that generator and disaggregator are compatible.</p> <p>Checks that the generator's output frequency matches the disaggregator's input frequency.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If frequencies are incompatible.</p>"},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline.preprocessing","title":"preprocessing","text":"<pre><code>preprocessing(**kwargs) -&gt; None\n</code></pre> <p>Preprocess both generator and disaggregator.</p> <p>Calls preprocessing() on both components in sequence.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional preprocessing parameters passed to both components.</p> <code>{}</code>"},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline.fit","title":"fit","text":"<pre><code>fit(**kwargs) -&gt; None\n</code></pre> <p>Fit both generator and disaggregator.</p> <p>Calls fit() on both components in sequence. Validates that preprocessing has been completed first.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional fitting parameters passed to both components.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If preprocessing has not been completed.</p>"},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline.generate","title":"generate","text":"<pre><code>generate(n_realizations: int = 1, n_years: Optional[int] = None, n_timesteps: Optional[int] = None, seed: Optional[int] = None, **kwargs) -&gt; Ensemble\n</code></pre> <p>Generate and disaggregate synthetic flows through the pipeline.</p> <p>This method orchestrates the complete workflow: 1. Generate monthly (or other coarse) synthetic flows using the generator 2. Disaggregate to finer temporal resolution using the disaggregator 3. Return the final ensemble</p> <p>Parameters:</p> Name Type Description Default <code>n_realizations</code> <code>int</code> <p>Number of synthetic realizations to generate.</p> <code>1</code> <code>n_years</code> <code>int</code> <p>Number of years to generate.</p> <code>None</code> <code>n_timesteps</code> <code>int</code> <p>Number of timesteps to generate explicitly.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>None</code> <code>**kwargs</code> <p>Additional parameters passed to generator and disaggregator.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Final disaggregated ensemble at the output frequency.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If pipeline has not been fitted.</p>"},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline.summary","title":"summary","text":"<pre><code>summary() -&gt; str\n</code></pre> <p>Generate a summary of the pipeline configuration and status.</p> <p>Returns:</p> Type Description <code>str</code> <p>Formatted summary string.</p>"},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline.save","title":"save","text":"<pre><code>save(filepath: str) -&gt; None\n</code></pre> <p>Save the entire pipeline to file.</p> <p>Saves both the generator and disaggregator, preserving their fitted state.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to save the pipeline.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If pipeline is not fitted.</p>"},{"location":"api/disaggregators/#synhydro.core.pipeline.GeneratorDisaggregatorPipeline.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(filepath: str) -&gt; GeneratorDisaggregatorPipeline\n</code></pre> <p>Load a pipeline from file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to saved pipeline file.</p> required <p>Returns:</p> Type Description <code>GeneratorDisaggregatorPipeline</code> <p>Loaded pipeline instance.</p>"},{"location":"api/disaggregators/#kirschnowakpipeline","title":"KirschNowakPipeline","text":""},{"location":"api/disaggregators/#synhydro.pipelines.prebuilt.KirschNowakPipeline","title":"KirschNowakPipeline","text":"<pre><code>KirschNowakPipeline(Q_obs: DataFrame, generate_using_log_flow: bool = True, matrix_repair_method: str = 'spectral', n_neighbors: int = 5, max_month_shift: int = 7, name: Optional[str] = None, debug: bool = False)\n</code></pre> <p>               Bases: <code>GeneratorDisaggregatorPipeline</code></p> <p>Pre-configured pipeline combining Kirsch generator with Nowak disaggregator.</p> <p>This pipeline generates monthly synthetic flows using the Kirsch nonparametric bootstrap method, then disaggregates them to daily flows using the Nowak KNN-based temporal disaggregation method.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>DataFrame</code> <p>Daily observed streamflow data with DatetimeIndex. Used to train both the generator (aggregated to monthly) and disaggregator (used as daily).</p> required <code>generate_using_log_flow</code> <code>bool</code> <p>Whether to generate in log-space (Kirsch parameter).</p> <code>True</code> <code>matrix_repair_method</code> <code>str</code> <p>Method for repairing correlation matrices (Kirsch parameter).</p> <code>'spectral'</code> <code>n_neighbors</code> <code>int</code> <p>Number of KNN neighbors for disaggregation (Nowak parameter).</p> <code>5</code> <code>max_month_shift</code> <code>int</code> <p>Maximum day shift for monthly profiles (Nowak parameter).</p> <code>7</code> <code>name</code> <code>str</code> <p>Name for this pipeline instance.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from synhydro.pipelines import KirschNowakPipeline\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load daily historic flows\n&gt;&gt;&gt; Q_daily = pd.read_csv('daily_flows.csv', index_col=0, parse_dates=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create pipeline\n&gt;&gt;&gt; pipeline = KirschNowakPipeline(Q_daily)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Fit and generate\n&gt;&gt;&gt; pipeline.preprocessing()\n&gt;&gt;&gt; pipeline.fit()\n&gt;&gt;&gt; daily_ensemble = pipeline.generate(n_realizations=100, n_years=50)\n</code></pre> Notes <p>This pipeline is equivalent to creating: <pre><code>generator = KirschGenerator(Q_obs, generate_using_log_flow=True)\ndisaggregator = NowakDisaggregator(Q_obs, n_neighbors=5)\npipeline = GeneratorDisaggregatorPipeline(generator, disaggregator)\n</code></pre></p> References <p>Kirsch generator: Nonparametric bootstrap with correlation preservation Nowak disaggregator: KNN-based temporal disaggregation (Nowak et al., 2010)</p> <p>Initialize the Kirsch-Nowak pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>DataFrame</code> <p>Daily observed streamflow data.</p> required <code>generate_using_log_flow</code> <code>bool</code> <p>Generate in log-space for Kirsch.</p> <code>True</code> <code>matrix_repair_method</code> <code>str</code> <p>Correlation matrix repair method for Kirsch.</p> <code>'spectral'</code> <code>n_neighbors</code> <code>int</code> <p>Number of KNN neighbors for Nowak.</p> <code>5</code> <code>max_month_shift</code> <code>int</code> <p>Day shift for Nowak monthly profiles.</p> <code>7</code> <code>name</code> <code>str</code> <p>Pipeline name.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code>"},{"location":"api/disaggregators/#thomasfieringnowakpipeline","title":"ThomasFieringNowakPipeline","text":""},{"location":"api/disaggregators/#synhydro.pipelines.prebuilt.ThomasFieringNowakPipeline","title":"ThomasFieringNowakPipeline","text":"<pre><code>ThomasFieringNowakPipeline(Q_obs, n_neighbors: int = 5, max_month_shift: int = 7, name: Optional[str] = None, debug: bool = False)\n</code></pre> <p>               Bases: <code>GeneratorDisaggregatorPipeline</code></p> <p>Pre-configured pipeline combining Thomas-Fiering generator with Nowak disaggregator.</p> <p>This pipeline generates monthly synthetic flows using the Thomas-Fiering AR(1) parametric method with Stedinger-Taylor normalization, then disaggregates them to daily flows using the Nowak KNN-based temporal disaggregation method.</p> <p>Note: Thomas-Fiering is a univariate method, so only single-site generation is supported. For multisite, use KirschNowakPipeline instead.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>Series or DataFrame</code> <p>Daily observed streamflow data with DatetimeIndex. If DataFrame, only the first column is used (Thomas-Fiering is univariate). Used to train both the generator (aggregated to monthly) and disaggregator (used as daily).</p> required <code>n_neighbors</code> <code>int</code> <p>Number of KNN neighbors for disaggregation (Nowak parameter).</p> <code>5</code> <code>max_month_shift</code> <code>int</code> <p>Maximum day shift for monthly profiles (Nowak parameter).</p> <code>7</code> <code>name</code> <code>str</code> <p>Name for this pipeline instance.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from synhydro.pipelines import ThomasFieringNowakPipeline\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load daily historic flows (single site)\n&gt;&gt;&gt; Q_daily = pd.read_csv('daily_flows.csv', index_col=0, parse_dates=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create pipeline\n&gt;&gt;&gt; pipeline = ThomasFieringNowakPipeline(Q_daily['site_1'])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Fit and generate\n&gt;&gt;&gt; pipeline.preprocessing()\n&gt;&gt;&gt; pipeline.fit()\n&gt;&gt;&gt; daily_ensemble = pipeline.generate(n_realizations=100, n_years=50)\n</code></pre> Notes <p>This pipeline is equivalent to creating: <pre><code>generator = ThomasFieringGenerator(Q_obs)\ndisaggregator = NowakDisaggregator(Q_obs, n_neighbors=5)\npipeline = GeneratorDisaggregatorPipeline(generator, disaggregator)\n</code></pre></p> References <p>Thomas-Fiering: AR(1) with Stedinger-Taylor normalization Nowak disaggregator: KNN-based temporal disaggregation (Nowak et al., 2010)</p> <p>Initialize the Thomas-Fiering-Nowak pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>Series or DataFrame</code> <p>Daily observed streamflow data. If DataFrame with multiple columns, only the first column is used (Thomas-Fiering is univariate).</p> required <code>n_neighbors</code> <code>int</code> <p>Number of KNN neighbors for Nowak.</p> <code>5</code> <code>max_month_shift</code> <code>int</code> <p>Day shift for Nowak monthly profiles.</p> <code>7</code> <code>name</code> <code>str</code> <p>Pipeline name.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code>"},{"location":"api/drought/","title":"Drought Metrics","text":""},{"location":"api/drought/#ssidroughtmetrics","title":"SSIDroughtMetrics","text":""},{"location":"api/drought/#synhydro.droughts.ssi.SSIDroughtMetrics","title":"SSIDroughtMetrics","text":"<pre><code>SSIDroughtMetrics(timescale: str = 'M', window: int = 12, dist: Union[str, ContinuousDist] = 'gamma', data=None)\n</code></pre> <p>Class to calculate and store drought metrics based on the Standardized Streamflow Index (SSI).</p> <p>Attributes:     timescale (str): Temporal scale ('D' for daily, 'M' for monthly).     window (int): Rolling window size for aggregation.     dist (ContinuousDist): Probability distribution for SSI calculation (default: gamma).     ssi (pd.Series): Series of SSI values.     drought_metrics (pd.DataFrame): DataFrame containing drought metrics.</p> <p>Initialize the SSIDroughtMetrics class.</p> <p>Parameters:</p> Name Type Description Default <code>timescale</code> <code>str</code> <p>Temporal scale: 'D' for daily, 'M' for monthly.</p> <code>'M'</code> <code>window</code> <code>int</code> <p>Rolling window size for aggregation before SSI calculation.</p> <code>12</code> <code>dist</code> <code>str or ContinuousDist</code> <p>Probability distribution to use for SSI calculation. Can be string name from registry or scipy distribution object. Common string options: 'gamma', 'lognorm', 'pearson3', 'weibull' Or pass scipy object directly: scs.gamma, scs.lognorm, etc.</p> <code>'gamma'</code> <code>data</code> <code>Series or DataFrame</code> <p>Initial data to set.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Using string name (recommended)\n&gt;&gt;&gt; ssi = SSIDroughtMetrics(dist='gamma')\n&gt;&gt;&gt; # Using scipy object directly\n&gt;&gt;&gt; import scipy.stats as scs\n&gt;&gt;&gt; ssi = SSIDroughtMetrics(dist=scs.lognorm)\n</code></pre>"},{"location":"api/drought/#synhydro.droughts.ssi.SSIDroughtMetrics.calculate_ssi","title":"calculate_ssi","text":"<pre><code>calculate_ssi(data=None)\n</code></pre> <p>Calculate the Standardized Streamflow Index (SSI).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Series or DataFrame</code> <p>Data to calculate SSI for. If None, uses previously set data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>SSI values.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no data is provided and no data was previously set.</p>"},{"location":"api/drought/#ssi","title":"SSI","text":""},{"location":"api/drought/#synhydro.droughts.ssi.SSI","title":"SSI  <code>dataclass</code>","text":"<pre><code>SSI(dist: Union[str, ContinuousDist] = 'gamma', timescale: int = 12, fit_freq: str | None = None, fit_window: int = 0, prob_zero: bool = False, normal_scores_transform: bool = False, agg_func: Literal['sum', 'mean'] = 'sum')\n</code></pre> <p>Independent SSI calculator that separates training and scoring phases.</p> <p>Uses the original spei.SI class internally for distribution fitting, then applies those fitted distributions to new data.</p> <p>Parameters:</p> Name Type Description Default <code>dist</code> <code>str or ContinuousDist</code> <p>Probability distribution for SSI calculation. Can be string name: 'gamma', 'lognorm', 'pearson3', 'weibull', etc. Or scipy distribution object.</p> <code>'gamma'</code> <code>timescale</code> <code>int</code> <p>Rolling window size for temporal aggregation.</p> <code>12</code> <code>fit_freq</code> <code>str</code> <p>Frequency for seasonal fitting ('M' for monthly, 'D' for daily). If None, fits single distribution to entire dataset.</p> <code>None</code> <code>fit_window</code> <code>int</code> <p>Moving window for distribution fitting.</p> <code>0</code> <code>prob_zero</code> <code>bool</code> <p>Whether to handle zero probability separately.</p> <code>False</code> <code>normal_scores_transform</code> <code>bool</code> <p>Whether to use normal scores transform instead of parametric fitting.</p> <code>False</code> <code>agg_func</code> <code>(sum, mean)</code> <p>Aggregation function for rolling window.</p> <code>'sum'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Basic usage with default gamma distribution\n&gt;&gt;&gt; ssi = SSI()\n&gt;&gt;&gt; ssi.fit(training_data)\n&gt;&gt;&gt; ssi_values = ssi.transform(new_data)\n</code></pre> <pre><code>&gt;&gt;&gt; # Using different distribution\n&gt;&gt;&gt; ssi = SSI(dist='lognorm', timescale=6)\n&gt;&gt;&gt; ssi.fit(training_data)\n</code></pre>"},{"location":"api/drought/#synhydro.droughts.ssi.SSI.fitted_distributions","title":"fitted_distributions  <code>property</code>","text":"<pre><code>fitted_distributions: dict\n</code></pre> <p>Access to fitted distributions (read-only).</p>"},{"location":"api/drought/#synhydro.droughts.ssi.SSI.fit","title":"fit","text":"<pre><code>fit(training_series: Series) -&gt; SSI\n</code></pre> <p>Fit distributions using training data.</p> <p>Parameters:</p> Name Type Description Default <code>training_series</code> <code>Series</code> <p>Time series data for fitting distributions</p> required <p>Returns:</p> Type Description <code>SSI</code> <p>Self for method chaining</p>"},{"location":"api/drought/#synhydro.droughts.ssi.SSI.transform","title":"transform","text":"<pre><code>transform(new_series: Series) -&gt; Series\n</code></pre> <p>Calculate SSI values for new data using fitted distributions.</p> <p>Parameters:</p> Name Type Description Default <code>new_series</code> <code>Series</code> <p>New time series data to transform</p> required <p>Returns:</p> Type Description <code>Series</code> <p>SSI values for the new series</p>"},{"location":"api/drought/#synhydro.droughts.ssi.SSI.fit_transform","title":"fit_transform","text":"<pre><code>fit_transform(training_series: Series, new_series: Series = None) -&gt; Series\n</code></pre> <p>Fit on training data and transform new data in one step.</p> <p>Parameters:</p> Name Type Description Default <code>training_series</code> <code>Series</code> <p>Data for fitting distributions</p> required <code>new_series</code> <code>Series</code> <p>Data to transform. If None, transforms training_series.</p> <code>None</code> <p>Returns:</p> Type Description <code>Series</code> <p>SSI values</p>"},{"location":"api/drought/#synhydro.droughts.ssi.SSI.get_training_ssi","title":"get_training_ssi","text":"<pre><code>get_training_ssi() -&gt; Series\n</code></pre> <p>Get SSI values for the training data.</p> <p>Returns:</p> Type Description <code>Series</code> <p>SSI values for training data</p>"},{"location":"api/drought/#functions","title":"Functions","text":""},{"location":"api/drought/#synhydro.droughts.ssi.get_drought_metrics","title":"get_drought_metrics","text":"<pre><code>get_drought_metrics(ssi, end_drought_threshold_months=3)\n</code></pre> <p>Calculate drought metrics from standardized supply index (SSI) time series.</p> <p>Parameters:</p> Name Type Description Default <code>ssi</code> <code>Series</code> <p>Time series of standardized supply index values</p> required <code>end_drought_threshold_months</code> <code>int</code> <p>Number of consecutive days with SSI &gt; 0 required to end a critical drought</p> <code>3</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing drought metrics for each identified drought event</p>"},{"location":"api/drought/#distribution-utilities","title":"Distribution Utilities","text":""},{"location":"api/drought/#synhydro.droughts.distributions","title":"distributions","text":"<p>Distribution management for drought analysis.</p> <p>This module provides utilities for working with probability distributions in drought analysis, including a registry of common distributions and helper functions for distribution selection.</p>"},{"location":"api/drought/#synhydro.droughts.distributions.get_distribution","title":"get_distribution","text":"<pre><code>get_distribution(name: Union[str, ContinuousDist]) -&gt; ContinuousDist\n</code></pre> <p>Get a distribution object by name or pass through if already a distribution.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or ContinuousDist</code> <p>Distribution name (e.g., 'gamma') or scipy distribution object.</p> required <p>Returns:</p> Type Description <code>ContinuousDist</code> <p>Scipy continuous distribution object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If distribution name is not recognized.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dist = get_distribution('gamma')\n&gt;&gt;&gt; dist = get_distribution(scs.gamma)  # Pass through\n</code></pre>"},{"location":"api/drought/#synhydro.droughts.distributions.list_distributions","title":"list_distributions","text":"<pre><code>list_distributions(include_info: bool = False) -&gt; Union[List[str], Dict[str, Dict[str, str]]]\n</code></pre> <p>List available distributions for drought analysis.</p> <p>Parameters:</p> Name Type Description Default <code>include_info</code> <code>bool</code> <p>If True, returns detailed information about each distribution. If False, returns only distribution names.</p> <code>False</code> <p>Returns:</p> Type Description <code>list or dict</code> <p>List of distribution names or dict with detailed information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; distributions = list_distributions()\n&gt;&gt;&gt; print(distributions)\n['gamma', 'lognorm', 'pearson3', ...]\n</code></pre> <pre><code>&gt;&gt;&gt; info = list_distributions(include_info=True)\n&gt;&gt;&gt; print(info['gamma']['description'])\n</code></pre>"},{"location":"api/drought/#synhydro.droughts.distributions.get_distribution_info","title":"get_distribution_info","text":"<pre><code>get_distribution_info(name: str) -&gt; Dict[str, str]\n</code></pre> <p>Get detailed information about a specific distribution.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Distribution name.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys: name, description, best_for, parameters.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If distribution name is not recognized.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; info = get_distribution_info('gamma')\n&gt;&gt;&gt; print(info['description'])\n</code></pre>"},{"location":"api/drought/#synhydro.droughts.distributions.print_distribution_guide","title":"print_distribution_guide","text":"<pre><code>print_distribution_guide()\n</code></pre> <p>Print a user-friendly guide to available distributions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print_distribution_guide()\n</code></pre>"},{"location":"api/drought/#synhydro.droughts.distributions.validate_distribution","title":"validate_distribution","text":"<pre><code>validate_distribution(dist: Union[str, ContinuousDist]) -&gt; ContinuousDist\n</code></pre> <p>Validate and normalize a distribution specification.</p> <p>Parameters:</p> Name Type Description Default <code>dist</code> <code>str or ContinuousDist</code> <p>Distribution name or scipy distribution object.</p> required <p>Returns:</p> Type Description <code>ContinuousDist</code> <p>Validated scipy distribution object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If distribution is invalid.</p> <code>TypeError</code> <p>If distribution type is not supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dist = validate_distribution('gamma')\n&gt;&gt;&gt; dist = validate_distribution(scs.lognorm)\n</code></pre>"},{"location":"api/generators/","title":"Generators","text":""},{"location":"api/generators/#base-class","title":"Base Class","text":""},{"location":"api/generators/#synhydro.core.base.Generator","title":"Generator","text":"<pre><code>Generator(Q_obs: Union[Series, DataFrame], name: Optional[str] = None, debug: bool = False)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for all synthetic generation methods.</p> <p>All generator implementations should inherit from this class.</p> <p>Initialize the generator base class.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>Series or DataFrame</code> <p>Observed historical flow data for training the generator.</p> required <code>name</code> <code>str</code> <p>Name identifier for this generator instance</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging</p> <code>False</code>"},{"location":"api/generators/#synhydro.core.base.Generator.is_fitted","title":"is_fitted  <code>property</code>","text":"<pre><code>is_fitted: bool\n</code></pre> <p>Check if generator is fitted.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.is_preprocessed","title":"is_preprocessed  <code>property</code>","text":"<pre><code>is_preprocessed: bool\n</code></pre> <p>Check if preprocessing is complete.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites: int\n</code></pre> <p>Number of sites in the generator.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of sites.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If preprocessing not yet run.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.sites","title":"sites  <code>property</code>","text":"<pre><code>sites: List[str]\n</code></pre> <p>List of site names.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>Site identifiers.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If preprocessing not yet run.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.output_frequency","title":"output_frequency  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>output_frequency: str\n</code></pre> <p>Temporal frequency of generated output.</p> <p>Returns:</p> Type Description <code>str</code> <p>Pandas frequency string (e.g., 'MS' for monthly, 'D' for daily).</p>"},{"location":"api/generators/#synhydro.core.base.Generator.validate_input_data","title":"validate_input_data","text":"<pre><code>validate_input_data(data: Union[Series, DataFrame]) -&gt; pd.DataFrame\n</code></pre> <p>Validate and standardize input data format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Series or DataFrame</code> <p>Input time series data</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Validated and standardized data</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data format is invalid</p> <code>TypeError</code> <p>If data type is unsupported</p>"},{"location":"api/generators/#synhydro.core.base.Generator.validate_preprocessing","title":"validate_preprocessing","text":"<pre><code>validate_preprocessing() -&gt; None\n</code></pre> <p>Check if preprocessing has been completed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If preprocessing() has not been run.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.validate_fit","title":"validate_fit","text":"<pre><code>validate_fit() -&gt; None\n</code></pre> <p>Check if generator has been fitted.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fit() has not been run.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.update_state","title":"update_state","text":"<pre><code>update_state(preprocessed: Optional[bool] = None, fitted: Optional[bool] = None) -&gt; None\n</code></pre> <p>Update generator state flags.</p> <p>Parameters:</p> Name Type Description Default <code>preprocessed</code> <code>bool</code> <p>Set preprocessing state.</p> <code>None</code> <code>fitted</code> <code>bool</code> <p>Set fitted state.</p> <code>None</code>"},{"location":"api/generators/#synhydro.core.base.Generator.get_params","title":"get_params","text":"<pre><code>get_params(deep: bool = True) -&gt; Dict[str, Any]\n</code></pre> <p>Get initialization parameters (scikit-learn style).</p> <p>Returns only constructor/configuration parameters, not fitted values. Following scikit-learn convention for compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>deep</code> <code>bool</code> <p>If True, return deep copy of parameters.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of initialization parameters.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.get_fitted_params","title":"get_fitted_params","text":"<pre><code>get_fitted_params() -&gt; Dict[str, Any]\n</code></pre> <p>Get parameters learned from data during fit().</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of fitted parameters (all keys end with underscore).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If generator has not been fitted yet.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.summary","title":"summary","text":"<pre><code>summary(show_fitted: bool = True) -&gt; str\n</code></pre> <p>Generate comprehensive summary of generator configuration and fit.</p> <p>Parameters:</p> Name Type Description Default <code>show_fitted</code> <code>bool</code> <p>Whether to include fitted parameters in summary.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted summary string.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.get_state_info","title":"get_state_info","text":"<pre><code>get_state_info() -&gt; Dict[str, Any]\n</code></pre> <p>Get complete state information including params and metadata.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing all generator state, parameters, and metadata.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.save","title":"save","text":"<pre><code>save(filepath: str) -&gt; None\n</code></pre> <p>Save fitted generator to file using pickle.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to save the generator.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If generator is not fitted.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.load","title":"load  <code>classmethod</code>","text":"<pre><code>load(filepath: str) -&gt; Generator\n</code></pre> <p>Load fitted generator from file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to saved generator file.</p> required <p>Returns:</p> Type Description <code>Generator</code> <p>Loaded generator instance.</p>"},{"location":"api/generators/#synhydro.core.base.Generator.preprocessing","title":"preprocessing  <code>abstractmethod</code>","text":"<pre><code>preprocessing(sites: Optional[List[str]] = None, **kwargs: Any) -&gt; None\n</code></pre> <p>Preprocess and validate observed flow data.</p> <p>Implementations should: 1. Call validate_input_data() to validate self._Q_obs_raw 2. Store preprocessed data as instance attributes 3. Call update_state(preprocessed=True) at end</p> <p>Parameters:</p> Name Type Description Default <code>sites</code> <code>List[str]</code> <p>List of site names to use. If None, uses all columns.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional preprocessing parameters.</p> <code>{}</code>"},{"location":"api/generators/#synhydro.core.base.Generator.fit","title":"fit  <code>abstractmethod</code>","text":"<pre><code>fit(**kwargs: Any) -&gt; None\n</code></pre> <p>Fit the generator to observed flow data.</p> <p>Implementations should: 1. Call validate_preprocessing() at start 2. Fit model parameters from preprocessed data 3. Store fitted parameters as instance attributes 4. Call update_state(fitted=True) at end</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional fitting parameters.</p> <code>{}</code>"},{"location":"api/generators/#synhydro.core.base.Generator.generate","title":"generate  <code>abstractmethod</code>","text":"<pre><code>generate(n_realizations: int = 1, n_years: Optional[int] = None, n_timesteps: Optional[int] = None, seed: Optional[int] = None, **kwargs: Any) -&gt; Ensemble\n</code></pre> <p>Generate synthetic streamflow realizations.</p> <p>Implementations should: 1. Call validate_fit() at start 2. Set random seed if provided 3. Generate synthetic flows 4. Return Ensemble object containing all realizations</p> <p>Parameters:</p> Name Type Description Default <code>n_realizations</code> <code>int</code> <p>Number of synthetic realizations to generate.</p> <code>1</code> <code>n_years</code> <code>int</code> <p>Number of years to generate (alternative to n_timesteps).</p> <code>None</code> <code>n_timesteps</code> <code>int</code> <p>Number of timesteps to generate explicitly.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional generation parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Generated synthetic flows as an Ensemble object.</p>"},{"location":"api/generators/#kirschgenerator","title":"KirschGenerator","text":""},{"location":"api/generators/#synhydro.methods.generation.nonparametric.kirsch.KirschGenerator","title":"KirschGenerator","text":"<pre><code>KirschGenerator(Q_obs: DataFrame, generate_using_log_flow=True, matrix_repair_method='spectral', name=None, debug=False, **kwargs)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Kirsch nonparametric bootstrap generator for monthly streamflow synthesis.</p> <p>Generates monthly synthetic flows using bootstrap resampling with correlation preservation.</p> <p>Initialize Kirsch generator.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>DataFrame</code> <p>Observed historical flow data with DatetimeIndex.</p> required <code>generate_using_log_flow</code> <code>bool</code> <p>If True, generates in log-space for better handling of skewed distributions.</p> <code>True</code> <code>matrix_repair_method</code> <code>str</code> <p>Method for repairing non-positive-definite correlation matrices.</p> <code>'spectral'</code> <code>name</code> <code>str</code> <p>Name for this generator instance.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code>"},{"location":"api/generators/#synhydro.methods.generation.nonparametric.kirsch.KirschGenerator.output_frequency","title":"output_frequency  <code>property</code>","text":"<pre><code>output_frequency: str\n</code></pre> <p>Kirsch generator produces monthly output.</p>"},{"location":"api/generators/#synhydro.methods.generation.nonparametric.kirsch.KirschGenerator.Q_obs_monthly","title":"Q_obs_monthly  <code>property</code>","text":"<pre><code>Q_obs_monthly\n</code></pre> <p>Get observed monthly data (alias for Qm for consistency with other generators).</p>"},{"location":"api/generators/#synhydro.methods.generation.nonparametric.kirsch.KirschGenerator.preprocessing","title":"preprocessing","text":"<pre><code>preprocessing(sites=None, timestep='monthly', **kwargs)\n</code></pre> <p>Preprocess observed data for Kirsch generation.</p> <p>Parameters:</p> Name Type Description Default <code>sites</code> <code>list</code> <p>Sites to use. If None, uses all sites.</p> <code>None</code> <code>timestep</code> <code>str</code> <p>Currently only 'monthly' is supported.</p> <code>'monthly'</code> <code>**kwargs</code> <p>Additional preprocessing parameters.</p> <code>{}</code>"},{"location":"api/generators/#synhydro.methods.generation.nonparametric.kirsch.KirschGenerator.fit","title":"fit","text":"<pre><code>fit(**kwargs)\n</code></pre> <p>Fit Kirsch generator to preprocessed data.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional fitting parameters.</p> <code>{}</code>"},{"location":"api/generators/#synhydro.methods.generation.nonparametric.kirsch.KirschGenerator.generate_single_series","title":"generate_single_series","text":"<pre><code>generate_single_series(n_years, M=None, as_array=True, synthetic_index=None)\n</code></pre> <p>Generate a single synthetic time series.</p> <p>Parameters:</p> Name Type Description Default <code>n_years</code> <code>int</code> <p>Number of years for the synthetic time series.</p> required <code>M</code> <code>ndarray</code> <p>Bootstrap indices for the synthetic time series. If None, random indices will be generated.</p> <code>None</code> <code>as_array</code> <code>bool</code> <p>If True, returns a numpy array; if False, returns a pandas DataFrame.</p> <code>True</code> <code>synthetic_index</code> <code>DatetimeIndex</code> <p>Custom index for the synthetic time series. If None, a default index will be generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray or DataFrame</code> <p>Synthetic time series data.</p>"},{"location":"api/generators/#synhydro.methods.generation.nonparametric.kirsch.KirschGenerator.generate","title":"generate","text":"<pre><code>generate(n_realizations=1, n_years=None, n_timesteps=None, seed=None, **kwargs)\n</code></pre> <p>Generate an ensemble of synthetic monthly flows.</p> <p>Parameters:</p> Name Type Description Default <code>n_realizations</code> <code>int</code> <p>Number of synthetic time series to generate.</p> <code>1</code> <code>n_years</code> <code>int</code> <p>Number of years for each synthetic time series. If None, uses the number of historic years.</p> <code>None</code> <code>n_timesteps</code> <code>int</code> <p>Not used (Kirsch generates by years, not timesteps).</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>None</code> <code>**kwargs</code> <p>Additional generation parameters.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Ensemble object containing all generated realizations.</p>"},{"location":"api/generators/#phaserandomizationgenerator","title":"PhaseRandomizationGenerator","text":""},{"location":"api/generators/#synhydro.methods.generation.nonparametric.phase_randomization.PhaseRandomizationGenerator","title":"PhaseRandomizationGenerator","text":"<pre><code>PhaseRandomizationGenerator(Q_obs: Union[Series, DataFrame], marginal: str = 'kappa', win_h_length: int = 15, name: Optional[str] = None, debug: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Phase randomization generator for synthetic streamflow using Brunner et al. (2019).</p> <p>Generates synthetic daily streamflow time series using Fourier transform phase randomization combined with the four-parameter kappa distribution. The method preserves both short- and long-range temporal dependence by conserving the power spectrum while randomizing phases.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>Series or DataFrame</code> <p>Observed daily streamflow data with DatetimeIndex. If DataFrame with multiple columns, only first column is used (with warning).</p> required <code>marginal</code> <code>str</code> <p>Marginal distribution type for back-transformation: - 'kappa': Four-parameter kappa distribution (default, allows extrapolation) - 'empirical': Empirical distribution (no extrapolation beyond observed)</p> <code>'kappa'</code> <code>win_h_length</code> <code>int</code> <p>Half-window length for daily distribution fitting. Values within \u00b1win_h_length days are used, giving a total window of 2*win_h_length+1 days.</p> <code>15</code> <code>name</code> <code>str</code> <p>Name identifier for this generator instance.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>par_day_</code> <code>dict</code> <p>Fitted kappa distribution parameters for each day of year (1-365). Each entry contains {'xi', 'alfa', 'k', 'h'}.</p> <code>modulus_</code> <code>ndarray</code> <p>Amplitude spectrum (modulus of FFT) from fitted data.</p> <code>phases_</code> <code>ndarray</code> <p>Phase spectrum from fitted data.</p> <code>norm_</code> <code>ndarray</code> <p>Normalized/deseasonalized data after normal score transform.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from synhydro.methods.generation.nonparametric import PhaseRandomizationGenerator\n&gt;&gt;&gt; Q_daily = pd.read_csv('daily_flows.csv', index_col=0, parse_dates=True)\n&gt;&gt;&gt; gen = PhaseRandomizationGenerator(Q_daily, marginal='kappa')\n&gt;&gt;&gt; gen.preprocessing()\n&gt;&gt;&gt; gen.fit()\n&gt;&gt;&gt; ensemble = gen.generate(n_realizations=100, seed=42)\n</code></pre> Notes <ul> <li>Requires at least 2 years (730 days) of daily data</li> <li>February 29 observations are removed to ensure consistent 365-day years</li> <li>The method generates series of the same length as the observed data</li> </ul> <p>Initialize the PhaseRandomizationGenerator.</p>"},{"location":"api/generators/#synhydro.methods.generation.nonparametric.phase_randomization.PhaseRandomizationGenerator.output_frequency","title":"output_frequency  <code>property</code>","text":"<pre><code>output_frequency: str\n</code></pre> <p>Phase randomization generates daily output.</p>"},{"location":"api/generators/#synhydro.methods.generation.nonparametric.phase_randomization.PhaseRandomizationGenerator.preprocessing","title":"preprocessing","text":"<pre><code>preprocessing(sites: Optional[list] = None, **kwargs) -&gt; None\n</code></pre> <p>Preprocess observed data for phase randomization generation.</p> <p>Validates input data, removes leap days, and creates day-of-year index.</p> <p>Parameters:</p> Name Type Description Default <code>sites</code> <code>list</code> <p>Not used (phase randomization is univariate).</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional preprocessing parameters (currently unused).</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has fewer than 730 days or has missing days.</p>"},{"location":"api/generators/#synhydro.methods.generation.nonparametric.phase_randomization.PhaseRandomizationGenerator.fit","title":"fit","text":"<pre><code>fit(**kwargs) -&gt; None\n</code></pre> <p>Fit the phase randomization model to observed data.</p> <p>This method: 1. Fits kappa distribution parameters for each day of year (if marginal='kappa') 2. Applies normal score transform per day of year 3. Computes FFT and extracts modulus/phases</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Additional fitting parameters (currently unused).</p> <code>{}</code>"},{"location":"api/generators/#synhydro.methods.generation.nonparametric.phase_randomization.PhaseRandomizationGenerator.generate","title":"generate","text":"<pre><code>generate(n_realizations: int = 1, n_years: Optional[int] = None, n_timesteps: Optional[int] = None, seed: Optional[int] = None, **kwargs) -&gt; Ensemble\n</code></pre> <p>Generate synthetic streamflow realizations using phase randomization.</p> <p>Parameters:</p> Name Type Description Default <code>n_realizations</code> <code>int</code> <p>Number of synthetic realizations to generate.</p> <code>1</code> <code>n_years</code> <code>int</code> <p>Not used (generates same length as observed data).</p> <code>None</code> <code>n_timesteps</code> <code>int</code> <p>Not used (generates same length as observed data).</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional generation parameters (currently unused).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Generated synthetic flows as an Ensemble object.</p>"},{"location":"api/generators/#thomasfieringgenerator","title":"ThomasFieringGenerator","text":""},{"location":"api/generators/#synhydro.methods.generation.parametric.thomas_fiering.ThomasFieringGenerator","title":"ThomasFieringGenerator","text":"<pre><code>ThomasFieringGenerator(Q_obs: Union[Series, DataFrame], name: Optional[str] = None, debug: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Thomas-Fiering autoregressive model for monthly streamflow generation.</p> <p>Generates synthetic monthly streamflows using a lag-1 autoregressive model with Stedinger-Taylor normalization. Preserves monthly means, standard deviations, and lag-1 serial correlations.</p> <p>Note: Thomas-Fiering is a univariate method (single site only).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from synhydro.methods.generate.parametric.thomas_fiering import ThomasFieringGenerator\n&gt;&gt;&gt; Q_monthly = pd.read_csv('monthly_flows.csv', index_col=0, parse_dates=True)\n&gt;&gt;&gt; tf = ThomasFieringGenerator(Q_monthly.iloc[:, 0])\n&gt;&gt;&gt; tf.preprocessing()\n&gt;&gt;&gt; tf.fit()\n&gt;&gt;&gt; ensemble = tf.generate(n_years=10, n_realizations=5)\n</code></pre> References <p>Thomas, H.A., and Fiering, M.B. (1962). Mathematical synthesis of streamflow sequences for the analysis of river basins by simulation.</p> <p>Stedinger, J.R., and Taylor, M.R. (1982). Synthetic streamflow generation: 1. Model verification and validation. Water Resources Research, 18(4), 909-918.</p> <p>Initialize the ThomasFieringGenerator.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>Series or DataFrame</code> <p>Streamflow data with DatetimeIndex. Must be single site. If not monthly frequency, will be resampled during preprocessing.</p> required <code>name</code> <code>str</code> <p>Name for this generator instance.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>Additional parameters (currently unused).</p> <code>{}</code>"},{"location":"api/generators/#synhydro.methods.generation.parametric.thomas_fiering.ThomasFieringGenerator.output_frequency","title":"output_frequency  <code>property</code>","text":"<pre><code>output_frequency: str\n</code></pre> <p>Thomas-Fiering generator produces monthly output.</p>"},{"location":"api/generators/#synhydro.methods.generation.parametric.thomas_fiering.ThomasFieringGenerator.preprocessing","title":"preprocessing","text":"<pre><code>preprocessing(sites: Optional[list] = None, **kwargs) -&gt; None\n</code></pre> <p>Preprocess observed data for Thomas-Fiering generation.</p> <p>Validates input, resamples to monthly if needed, and applies Stedinger-Taylor normalization.</p> <p>Parameters:</p> Name Type Description Default <code>sites</code> <code>list</code> <p>Not used (Thomas-Fiering is univariate).</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional parameters (currently unused).</p> <code>{}</code>"},{"location":"api/generators/#synhydro.methods.generation.parametric.thomas_fiering.ThomasFieringGenerator.fit","title":"fit","text":"<pre><code>fit(**kwargs) -&gt; None\n</code></pre> <p>Estimate Thomas-Fiering model parameters from normalized flows.</p> <p>Calculates monthly means, standard deviations, and lag-1 serial correlations from normalized flows.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Additional parameters (currently unused).</p> <code>{}</code>"},{"location":"api/generators/#synhydro.methods.generation.parametric.thomas_fiering.ThomasFieringGenerator.generate","title":"generate","text":"<pre><code>generate(n_years: Optional[int] = None, n_realizations: int = 1, n_timesteps: Optional[int] = None, seed: Optional[int] = None, **kwargs) -&gt; Ensemble\n</code></pre> <p>Generate synthetic monthly streamflows.</p> <p>Parameters:</p> Name Type Description Default <code>n_years</code> <code>int</code> <p>Number of years to generate per realization. If None, uses the length of historic data.</p> <code>None</code> <code>n_realizations</code> <code>int</code> <p>Number of synthetic realizations to generate.</p> <code>1</code> <code>n_timesteps</code> <code>int</code> <p>Number of monthly timesteps to generate. If provided, overrides n_years.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional parameters (currently unused).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Ensemble object containing all realizations.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither n_years nor n_timesteps is provided.</p>"},{"location":"api/generators/#matalasgenerator","title":"MATALASGenerator","text":""},{"location":"api/generators/#synhydro.methods.generation.parametric.matalas.MATALASGenerator","title":"MATALASGenerator","text":"<pre><code>MATALASGenerator(Q_obs, log_transform: bool = True, name: Optional[str] = None, debug: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Matalas (1967) multi-site monthly lag-1 autoregressive (MAR(1)) model.</p> <p>The standard classical baseline for parametric multi-site stochastic generation. Extends the Thomas-Fiering univariate model to n sites using matrix autoregression, preserving contemporaneous cross-site correlations and lag-1 temporal structure at each site.</p> <p>For each monthly transition m \u2192 m+1, generates:</p> <pre><code>Z(t+1) = A(m) \u00b7 Z(t) + B(m) \u00b7 \u03b5(t+1)\n</code></pre> <p>where Z are standardized flows across all sites, \u03b5 ~ N(0, I), and A, B are coefficient matrices fitted from observed cross-correlations.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>DataFrame or Series</code> <p>Monthly streamflow with DatetimeIndex. If Series, treated as single site (equivalent to Thomas-Fiering). Columns are sites.</p> required <code>log_transform</code> <code>bool</code> <p>Apply log(Q + 1) transformation before standardization to reduce skewness and improve normality assumption.</p> <code>True</code> <code>name</code> <code>str</code> <p>Name for this generator instance.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code> Notes <p>The coefficient matrices are derived from the lag-0 and lag-1 cross-correlation matrices of the standardized flows:</p> <pre><code>A(m) = S\u2081(m) \u00b7 S\u2080(m)\u207b\u00b9\nB(m) \u00b7 B(m)\u1d40 = S\u2080(m+1) - A(m) \u00b7 S\u2080(m) \u00b7 A(m)\u1d40\n</code></pre> <p>where S\u2080(m) is the contemporaneous correlation matrix at month m and S\u2081(m) is the lag-1 cross-correlation between months m+1 and m. B(m) is the lower Cholesky factor of the residual covariance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gen = MATALASGenerator(Q_monthly)\n&gt;&gt;&gt; gen.preprocessing()\n&gt;&gt;&gt; gen.fit()\n&gt;&gt;&gt; ensemble = gen.generate(n_years=100, n_realizations=50, seed=42)\n</code></pre> References <p>Matalas, N. C. (1967). Mathematical assessment of synthetic hydrology. Water Resources Research, 3(4), 937\u2013945.</p> <p>Salas, J. D., Delleur, J. W., Yevjevich, V., &amp; Lane, W. L. (1980). Applied Modeling of Hydrologic Time Series. Water Resources Publications.</p>"},{"location":"api/generators/#synhydro.methods.generation.parametric.matalas.MATALASGenerator.preprocessing","title":"preprocessing","text":"<pre><code>preprocessing(sites: Optional[list] = None, **kwargs) -&gt; None\n</code></pre> <p>Validate input and resample to monthly frequency.</p> <p>Parameters:</p> Name Type Description Default <code>sites</code> <code>list</code> <p>Subset of site columns to use. Uses all columns if None.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Unused.</p> <code>{}</code>"},{"location":"api/generators/#synhydro.methods.generation.parametric.matalas.MATALASGenerator.fit","title":"fit","text":"<pre><code>fit(**kwargs) -&gt; None\n</code></pre> <p>Estimate MAR(1) coefficient matrices from observed monthly flows.</p> <p>For each of the 12 monthly transitions, computes lag-0 (S0) and lag-1 (S1) cross-correlation matrices then solves for A and B.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Unused.</p> <code>{}</code>"},{"location":"api/generators/#synhydro.methods.generation.parametric.matalas.MATALASGenerator.generate","title":"generate","text":"<pre><code>generate(n_years: Optional[int] = None, n_realizations: int = 1, n_timesteps: Optional[int] = None, seed: Optional[int] = None, **kwargs) -&gt; Ensemble\n</code></pre> <p>Generate synthetic monthly streamflows at all sites.</p> <p>Parameters:</p> Name Type Description Default <code>n_years</code> <code>int</code> <p>Years per realization. Defaults to length of historic record.</p> <code>None</code> <code>n_realizations</code> <code>int</code> <p>Number of independent synthetic sequences.</p> <code>1</code> <code>n_timesteps</code> <code>int</code> <p>Total monthly timesteps; overrides n_years when provided.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Unused.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Collection of synthetic realizations.</p>"},{"location":"api/generators/#multisitehmmgenerator","title":"MultiSiteHMMGenerator","text":""},{"location":"api/generators/#synhydro.methods.generation.parametric.multisite_hmm.MultiSiteHMMGenerator","title":"MultiSiteHMMGenerator","text":"<pre><code>MultiSiteHMMGenerator(Q_obs: Union[Series, DataFrame], n_states: int = 2, offset: float = 1.0, max_iterations: int = 1000, covariance_type: str = 'full', name: Optional[str] = None, debug: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Multi-site Hidden Markov Model generator for synthetic streamflow.</p> <p>Generates synthetic streamflow using a Gaussian Mixture Model HMM that models temporal dependencies through hidden states and spatial correlations through multivariate Gaussian emissions with state-specific covariance matrices.</p> <p>The method is particularly suited for capturing drought dynamics across multiple sites/basins simultaneously.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>Series or DataFrame</code> <p>Observed streamflow data with DatetimeIndex. Must be DataFrame for multi-site generation (multiple columns = multiple sites).</p> required <code>n_states</code> <code>int</code> <p>Number of hidden states. Default is 2 (dry/wet states).</p> <code>2</code> <code>offset</code> <code>float</code> <p>Small value added before log transformation to handle zeros. Recommended: 1.0 for flows in standard units.</p> <code>1.0</code> <code>max_iterations</code> <code>int</code> <p>Maximum iterations for HMM fitting convergence.</p> <code>1000</code> <code>covariance_type</code> <code>str</code> <p>Type of covariance matrix: - 'full': Full covariance matrix (captures all correlations) - 'diag': Diagonal covariance (independent sites) - 'spherical': Single variance for all dimensions</p> <code>'full'</code> <code>name</code> <code>str</code> <p>Name identifier for this generator instance.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>means_</code> <code>ndarray</code> <p>State means for each site. Shape: (n_states, n_sites).</p> <code>covariances_</code> <code>ndarray</code> <p>Covariance matrices for each state. Shape: (n_states, n_sites, n_sites).</p> <code>transition_matrix_</code> <code>ndarray</code> <p>State transition probability matrix. Shape: (n_states, n_states).</p> <code>stationary_distribution_</code> <code>ndarray</code> <p>Stationary distribution of states. Shape: (n_states,).</p> <code>Q_log_</code> <code>ndarray</code> <p>Log-transformed observed flows used for fitting.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from synhydro.methods.generation.parametric import MultiSiteHMMGenerator\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Load multi-site annual flows\n&gt;&gt;&gt; Q_annual = pd.read_csv('annual_flows.csv', index_col=0, parse_dates=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Initialize generator\n&gt;&gt;&gt; gen = MultiSiteHMMGenerator(Q_annual, n_states=2)\n&gt;&gt;&gt; gen.preprocessing()\n&gt;&gt;&gt; gen.fit()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Generate 100 realizations of 50 years each\n&gt;&gt;&gt; ensemble = gen.generate(n_realizations=100, n_years=50, seed=42)\n</code></pre> Notes <ul> <li>Designed for annual timestep data (can handle other frequencies)</li> <li>Log transformation ensures positive emissions</li> <li>Full covariance preserves spatial correlations between sites</li> <li>State ordering: states sorted by mean (low mean = dry state)</li> </ul> <p>Initialize the MultiSiteHMMGenerator.</p>"},{"location":"api/generators/#synhydro.methods.generation.parametric.multisite_hmm.MultiSiteHMMGenerator.output_frequency","title":"output_frequency  <code>property</code>","text":"<pre><code>output_frequency: str\n</code></pre> <p>Output frequency matches input frequency.</p> <p>Typically used for annual data ('YS' or 'AS'), but flexible.</p>"},{"location":"api/generators/#synhydro.methods.generation.parametric.multisite_hmm.MultiSiteHMMGenerator.preprocessing","title":"preprocessing","text":"<pre><code>preprocessing(sites: Optional[List[str]] = None, **kwargs) -&gt; None\n</code></pre> <p>Preprocess observed data for HMM fitting.</p> <p>Applies offset and log transformation to handle zeros and ensure positive values for fitting.</p> <p>Parameters:</p> Name Type Description Default <code>sites</code> <code>List[str]</code> <p>Subset of sites to use. If None, uses all columns.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional preprocessing parameters (currently unused).</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If data has fewer than 2 sites for multi-site modeling.</p>"},{"location":"api/generators/#synhydro.methods.generation.parametric.multisite_hmm.MultiSiteHMMGenerator.fit","title":"fit","text":"<pre><code>fit(random_state: Optional[int] = None, **kwargs) -&gt; None\n</code></pre> <p>Fit the multi-site HMM to observed data.</p> <p>Estimates hidden states, transition probabilities, state-specific means, and covariance matrices using the GMMHMM algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>random_state</code> <code>int</code> <p>Random seed for reproducible fitting. If None, fitting may vary.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional fitting parameters (currently unused).</p> <code>{}</code> Notes <p>States are automatically ordered by mean (ascending), so state 0 represents the dry state and higher-numbered states represent progressively wetter states.</p>"},{"location":"api/generators/#synhydro.methods.generation.parametric.multisite_hmm.MultiSiteHMMGenerator.generate","title":"generate","text":"<pre><code>generate(n_realizations: int = 1, n_years: Optional[int] = None, n_timesteps: Optional[int] = None, seed: Optional[int] = None, **kwargs) -&gt; Ensemble\n</code></pre> <p>Generate synthetic streamflow realizations.</p> <p>Parameters:</p> Name Type Description Default <code>n_realizations</code> <code>int</code> <p>Number of synthetic realizations to generate.</p> <code>1</code> <code>n_years</code> <code>int</code> <p>Number of years to generate. If provided with annual data, this equals n_timesteps.</p> <code>None</code> <code>n_timesteps</code> <code>int</code> <p>Number of timesteps to generate explicitly. Takes precedence over n_years if both provided.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional generation parameters (currently unused).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Generated synthetic flows as an Ensemble object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither n_years nor n_timesteps is provided.</p>"},{"location":"api/generators/#warmgenerator","title":"WARMGenerator","text":""},{"location":"api/generators/#synhydro.methods.generation.parametric.warm.WARMGenerator","title":"WARMGenerator","text":"<pre><code>WARMGenerator(Q_obs: Union[Series, DataFrame], wavelet: str = 'morl', scales: int = 64, ar_order: int = 1, name: Optional[str] = None, debug: bool = False, **kwargs)\n</code></pre> <p>               Bases: <code>Generator</code></p> <p>Wavelet Auto-Regressive Method (WARM) for non-stationary streamflow generation.</p> <p>Implements the 4-step WARM methodology: 1. Wavelet transform decomposition into periodic components 2. Scale Averaged Wavelet Power (SAWP) calculation for time-varying normalization 3. AR model fitting to scaled wavelet coefficients 4. Stochastic generation with inverse wavelet transform</p> <p>The SAWP approach enables preservation of non-stationary spectral characteristics and time-varying variability in synthetic sequences.</p> <p>Note: WARM is designed for annual streamflow generation (univariate).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from synhydro.methods.generation.parametric.warm import WARMGenerator\n&gt;&gt;&gt; Q_annual = pd.read_csv('annual_flows.csv', index_col=0, parse_dates=True)\n&gt;&gt;&gt; warm = WARMGenerator(Q_annual.iloc[:, 0], wavelet='morlet', scales=64)\n&gt;&gt;&gt; warm.preprocessing()\n&gt;&gt;&gt; warm.fit()\n&gt;&gt;&gt; ensemble = warm.generate(n_years=100, n_realizations=50, seed=42)\n</code></pre> References <p>Nowak, K., Rajagopalan, B., &amp; Zagona, E. (2011). A Wavelet Auto-Regressive Method (WARM) for multi-site streamflow simulation of data with non-stationary trends. Journal of Hydrology, 410(1-2), 1-12.</p> <p>Kwon, H.-H., Lall, U., &amp; Khalil, A. F. (2007). Stochastic simulation model for nonstationary time series using an autoregressive wavelet decomposition: Applications to rainfall and temperature. Water Resources Research, 43(5).</p> <p>Initialize the WARM Generator.</p> <p>Parameters:</p> Name Type Description Default <code>Q_obs</code> <code>Series or DataFrame</code> <p>Annual streamflow data with DatetimeIndex. Must be single site. If DataFrame provided, will use first column only.</p> required <code>wavelet</code> <code>str</code> <p>Wavelet type for continuous wavelet transform. Options: 'morl' (Morlet), 'mexh' (Mexican Hat), 'gaus1'-'gaus8'. Morlet wavelet recommended for hydrologic applications.</p> <code>'morl'</code> <code>scales</code> <code>int</code> <p>Number of scales for wavelet decomposition. Higher values capture more frequency components but increase computational cost.</p> <code>64</code> <code>ar_order</code> <code>int</code> <p>Order of autoregressive model for each wavelet scale. Default AR(1) preserves temporal persistence.</p> <code>1</code> <code>name</code> <code>str</code> <p>Name for this generator instance.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable debug logging.</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>Additional parameters (currently unused).</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If scales &lt; 2 or ar_order &lt; 1.</p>"},{"location":"api/generators/#synhydro.methods.generation.parametric.warm.WARMGenerator.output_frequency","title":"output_frequency  <code>property</code>","text":"<pre><code>output_frequency: str\n</code></pre> <p>WARM generator produces annual output.</p>"},{"location":"api/generators/#synhydro.methods.generation.parametric.warm.WARMGenerator.preprocessing","title":"preprocessing","text":"<pre><code>preprocessing(sites: Optional[list] = None, **kwargs) -&gt; None\n</code></pre> <p>Preprocess observed data for WARM generation.</p> <p>Validates input data and ensures annual frequency. WARM is designed for annual streamflow generation.</p> <p>Parameters:</p> Name Type Description Default <code>sites</code> <code>list</code> <p>Not used (WARM is univariate).</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional parameters (currently unused).</p> <code>{}</code>"},{"location":"api/generators/#synhydro.methods.generation.parametric.warm.WARMGenerator.fit","title":"fit","text":"<pre><code>fit(**kwargs) -&gt; None\n</code></pre> <p>Fit WARM model to observed annual flows.</p> <p>Implements the 4-step WARM methodology: 1. Continuous wavelet transform 2. Scale Averaged Wavelet Power (SAWP) calculation 3. Normalization by SAWP 4. AR model fitting to scaled coefficients</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>dict</code> <p>Additional parameters (currently unused).</p> <code>{}</code>"},{"location":"api/generators/#synhydro.methods.generation.parametric.warm.WARMGenerator.generate","title":"generate","text":"<pre><code>generate(n_years: Optional[int] = None, n_realizations: int = 1, n_timesteps: Optional[int] = None, seed: Optional[int] = None, **kwargs) -&gt; Ensemble\n</code></pre> <p>Generate synthetic annual streamflows using WARM.</p> <p>Parameters:</p> Name Type Description Default <code>n_years</code> <code>int</code> <p>Number of years to generate per realization. If None, uses the length of historic data.</p> <code>None</code> <code>n_realizations</code> <code>int</code> <p>Number of synthetic realizations to generate.</p> <code>1</code> <code>n_timesteps</code> <code>int</code> <p>Number of annual timesteps to generate. If provided, overrides n_years. For WARM, n_timesteps = n_years (annual data).</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional parameters (currently unused).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Ensemble</code> <p>Ensemble object containing all realizations.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither n_years nor n_timesteps is provided.</p>"},{"location":"references/references/","title":"References","text":""},{"location":"references/references/#parametric-methods","title":"Parametric Methods","text":"<p>Thomas-Fiering AR(1) Thomas, H.A., and Fiering, M.B. (1962). Mathematical synthesis of streamflow sequences for the analysis of river basins by simulation. In Design of Water Resource Systems (eds. Maass et al.), pp. 459-493. Harvard University Press.</p> <p>Matalas MAR(1) Matalas, N.C. (1967). Mathematical assessment of synthetic hydrology. Water Resources Research, 3(4), 937\u2013945. https://doi.org/10.1029/WR003i004p00937</p> <p>Multi-Site Hidden Markov Model Gold, D.F., Reed, P.M., and Gupta, R.S. (2024). Exploring the spatially compounding multi-sectoral drought vulnerabilities in Colorado's West Slope river basins. Earth's Future. https://doi.org/10.1029/2023EF004126</p> <p>Stedinger-Taylor Normalization (used in Thomas-Fiering) Stedinger, J.R., and Taylor, M.R. (1982). Synthetic streamflow generation: 1. Model verification and validation. Water Resources Research, 18(4), 909-918. https://doi.org/10.1029/WR018i004p00909</p>"},{"location":"references/references/#nonparametric-methods","title":"Nonparametric Methods","text":"<p>Kirsch Monthly Bootstrap Kirsch, B.R., Characklis, G.W., and Zeff, H.B. (2013). Evaluating the impact of alternative hydro-climate scenarios on transfer agreements: A practical improvement for generating synthetic streamflows. Journal of Water Resources Planning and Management, 139(4), 396-406. https://doi.org/10.1061/(ASCE)WR.1943-5452.0000287</p> <p>Phase Randomization Brunner, M.I., B\u00e1rdossy, A., and Furrer, R. (2019). Technical note: Stochastic simulation of streamflow time series using phase randomization. Hydrology and Earth System Sciences, 23, 3175-3187. https://doi.org/10.5194/hess-23-3175-2019</p>"},{"location":"references/references/#disaggregation","title":"Disaggregation","text":"<p>Nowak Annual-to-Daily Disaggregation Nowak, K., Prairie, J., Rajagopalan, B., and Lall, U. (2010). A nonparametric stochastic approach for multisite disaggregation of annual to daily streamflow. Water Resources Research, 46(8). https://doi.org/10.1029/2009WR008530</p>"},{"location":"references/references/#wavelet-based-methods","title":"Wavelet-Based Methods","text":"<p>WARM (Wavelet Auto-Regressive Method) Erkyihun, S.T., Rajagopalan, B., Zagona, E., Lall, U., and Nowak, K. (2016). Wavelet-based time series bootstrap model for multidecadal streamflow simulation using climate indicators. Water Resources Research, 52(5), 4061-4077. https://doi.org/10.1002/2016WR018696</p> <p>Nowak, K., Rajagopalan, B., and Zagona, E. (2011). A Wavelet Auto-Regressive Method (WARM) for multi-site streamflow simulation of data with non-stationary trends. Journal of Hydrology, 410(1-2), 1-12. https://doi.org/10.1016/j.jhydrol.2011.08.049</p>"},{"location":"references/references/#methodological-foundations","title":"Methodological Foundations","text":"<p>Applied stochastic hydrology Salas, J.D., Delleur, J.W., Yevjevich, V., and Lane, W.L. (1980). Applied Modeling of Hydrologic Time Series. Water Resources Publications.</p> <p>L-moments Hosking, J.R.M. (1990). L-moments: Analysis and estimation of distributions using linear combinations of order statistics. Journal of the Royal Statistical Society Series B, 52, 105-124. https://doi.org/10.1111/j.2517-6161.1990.tb01775.x</p> <p>Kappa distribution Hosking, J.R.M. (1994). The four-parameter kappa distribution. IBM Journal of Research and Development, 38, 251-258. https://doi.org/10.1147/rd.383.0251</p> <p>Surrogate data / phase randomization theory Theiler, J., Eubank, S., Longtin, A., Galdrikian, B., and Farmer, J.D. (1992). Testing for nonlinearity in time series: the method of surrogate data. Physica D, 58, 77-94. https://doi.org/10.1016/0167-2789(92)90102-S</p> <p>Hidden Markov Models Rabiner, L.R. (1989). A tutorial on hidden Markov models and selected applications in speech recognition. Proceedings of the IEEE, 77(2), 257-286. https://doi.org/10.1109/5.18626</p> <p>GMMHMM for hydrology Akintug, B., and Rasmussen, P.F. (2005). A Markov switching model for annual hydrologic time series. Water Resources Research, 41(9). https://doi.org/10.1029/2004WR003605</p> <p>Wavelet analysis Torrence, C., and Compo, G.P. (1998). A practical guide to wavelet analysis. Bulletin of the American Meteorological Society, 79(1), 61-78. https://doi.org/10.1175/1520-0477(1998)079&lt;0061:APGTWA&gt;2.0.CO;2</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Concise examples covering the core SynHydro workflows.</p> Tutorial Generator Description Quickstart <code>ThomasFieringGenerator</code> Single-site monthly generation Multi-Site Monthly <code>KirschGenerator</code> Multi-site nonparametric bootstrap Monthly\u2192Daily Pipeline <code>KirschNowakPipeline</code> Full monthly-to-daily workflow Drought Analysis <code>SSIDroughtMetrics</code> SSI calculation and drought metrics <p>All examples use <code>synhydro.load_example_data()</code>, which returns a multi-site daily streamflow <code>DataFrame</code>.</p>"},{"location":"tutorials/01_quickstart/","title":"Quickstart: Single-Site Monthly Generation","text":"<p>The <code>ThomasFieringGenerator</code> fits a seasonal AR(1) model to single-site monthly streamflow.</p> <pre><code>import synhydro\n\n# Load example data and extract a single site\nQ_daily = synhydro.load_example_data()\nQ_monthly = Q_daily.resample(\"MS\").mean().iloc[:, [0]]   # single-site monthly\n\n# Fit and generate\ngen = synhydro.ThomasFieringGenerator(Q_monthly)\ngen.preprocessing()\ngen.fit()\nensemble = gen.generate(n_realizations=10, n_years=30, seed=42)\n</code></pre> <p>The returned <code>ensemble</code> object contains 10 synthetic 30-year monthly timeseries.</p> <pre><code># Access realizations\nQ_syn_0 = ensemble.data_by_realization[0]    # first realization (DataFrame)\nprint(Q_syn_0.shape)                          # (360, 1) \u2014 360 months \u00d7 1 site\n\n# Summary of fitted parameters\ngen.summary()\n</code></pre> <p>Seed reproducibility</p> <p>Passing the same <code>seed</code> value to <code>generate()</code> always produces identical results.</p> <p>Algorithm details: Thomas-Fiering AR(1)</p>"},{"location":"tutorials/02_multisite/","title":"Multi-Site Monthly Generation","text":"<p><code>KirschGenerator</code> uses nonparametric bootstrap with Cholesky decomposition to preserve cross-site correlations in monthly streamflow.</p> <pre><code>import synhydro\n\n# Multi-site monthly data\nQ_daily = synhydro.load_example_data()\nQ_monthly = Q_daily.resample(\"MS\").mean()\n\ngen = synhydro.KirschGenerator(Q_monthly)\ngen.preprocessing()\ngen.fit()\nensemble = gen.generate(n_realizations=50, n_years=30, seed=42)\n</code></pre> <pre><code># Access by realization or by site\nQ_syn_0 = ensemble.data_by_realization[0]      # shape: (360, n_sites)\nQ_site_A = ensemble.data_by_site[Q_monthly.columns[0]]\n\n# Cross-site correlations are preserved\nprint(Q_syn_0.corr())\n</code></pre> <p>Algorithm details: Kirsch Bootstrap</p>"},{"location":"tutorials/03_pipeline/","title":"Monthly\u2192Daily Pipeline","text":"<p><code>KirschNowakPipeline</code> combines the Kirsch monthly generator with the Nowak KNN disaggregator. It accepts only daily observed data and handles internal aggregation.</p> <pre><code>import synhydro\n\nQ_daily = synhydro.load_example_data()                     # daily observed flows\n\npipeline = synhydro.KirschNowakPipeline(Q_daily)\npipeline.preprocessing()\npipeline.fit()\ndaily_ensemble = pipeline.generate(n_realizations=10, n_years=30, seed=42)\n</code></pre> <p>The output ensemble contains daily synthetic flows, preserving both the monthly statistical structure (from Kirsch) and within-month daily patterns (from Nowak).</p> <pre><code># First realization \u2014 daily DataFrame\nQ_syn_daily = daily_ensemble.data_by_realization[0]\nprint(Q_syn_daily.shape)                                 # (~10957 days \u00d7 n_sites)\n</code></pre> <p>Thomas-Fiering + Nowak</p> <p>A single-site monthly\u2192daily pipeline is also available: <pre><code>pipeline = synhydro.ThomasFieringNowakPipeline(Q_daily)\n</code></pre></p> <p>Algorithm details: Kirsch Bootstrap \u00b7 Nowak Disaggregation</p>"},{"location":"tutorials/04_drought_analysis/","title":"Drought Analysis","text":"<p>SynHydro provides Standardized Streamflow Index (SSI) calculation and drought metric extraction via <code>SSIDroughtMetrics</code>.</p>"},{"location":"tutorials/04_drought_analysis/#ssi-calculation","title":"SSI Calculation","text":"<pre><code>import synhydro\n\nQ_daily = synhydro.load_example_data()\nQ_monthly = Q_daily.resample(\"MS\").mean()\nsite = Q_monthly.columns[0]\n\n# Calculate 12-month SSI using gamma distribution\nssi_calc = synhydro.SSIDroughtMetrics(timescale=\"M\", window=12, dist=\"gamma\")\nssi = ssi_calc.calculate_ssi(Q_monthly[site])\n</code></pre> <p>The SSI series has mean \u2248 0 and std \u2248 1. Values below \u22121 indicate moderate-to-severe drought.</p>"},{"location":"tutorials/04_drought_analysis/#drought-metrics","title":"Drought Metrics","text":"<pre><code>metrics = synhydro.get_drought_metrics(ssi)\nprint(metrics.head())\n</code></pre> <p>Returned columns include: <code>duration</code>, <code>magnitude</code>, <code>severity</code> (minimum SSI), and <code>avg_severity</code> for each identified drought event.</p>"},{"location":"tutorials/04_drought_analysis/#comparing-observed-vs-synthetic","title":"Comparing Observed vs. Synthetic","text":"<pre><code>gen = synhydro.KirschGenerator(Q_monthly)\ngen.preprocessing()\ngen.fit()\nensemble = gen.generate(n_realizations=20, n_years=30, seed=42)\n\n# Compute SSI for each realization\nsyn_ssi_list = []\nfor i, Q_syn in ensemble.data_by_realization.items():\n    ssi_syn = ssi_calc.calculate_ssi(Q_syn.iloc[:, 0])\n    syn_ssi_list.append(ssi_syn)\n</code></pre> <p>Algorithm details: Thomas-Fiering AR(1) \u00b7 Kirsch Bootstrap</p>"}]}